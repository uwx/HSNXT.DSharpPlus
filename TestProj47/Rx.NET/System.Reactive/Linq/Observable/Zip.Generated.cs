// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information. 

using System.Reactive.Disposables;

namespace System.Reactive.Linq.ObservableImpl
{
    #region [3,16]-ary

    /* The following code is generated by a T4 template. */

    #region Zip auto-generated code (4/21/2017 10:40:30 AM)

    internal sealed class Zip<T1, T2, T3, TResult> : Producer<TResult, Zip<T1, T2, T3, TResult>._>
    {
        private readonly IObservable<T1> _source1;
        private readonly IObservable<T2> _source2;
        private readonly IObservable<T3> _source3;
        private readonly Func<T1, T2, T3, TResult> _resultSelector;

        public Zip(IObservable<T1> source1, IObservable<T2> source2, IObservable<T3> source3, Func<T1, T2, T3, TResult> resultSelector)
        {
            _source1 = source1;
            _source2 = source2;
            _source3 = source3;
            _resultSelector = resultSelector;
        }

        protected override _ CreateSink(IObserver<TResult> observer, IDisposable cancel) => new _(_resultSelector, observer, cancel);

        protected override IDisposable Run(_ sink) => sink.Run(_source1, _source2, _source3);

        internal sealed class _ : ZipSink<TResult>
        {
            private readonly Func<T1, T2, T3, TResult> _resultSelector;

            public _(Func<T1, T2, T3, TResult> resultSelector, IObserver<TResult> observer, IDisposable cancel)
                : base(3, observer, cancel)
            {
                _resultSelector = resultSelector;
            }

            private ZipObserver<T1> _observer1;
            private ZipObserver<T2> _observer2;
            private ZipObserver<T3> _observer3;

            public IDisposable Run(IObservable<T1> source1, IObservable<T2> source2, IObservable<T3> source3)
            {
                var disposables = new IDisposable[4];

                var d1 = new SingleAssignmentDisposable();
                disposables[0] = d1;
                _observer1 = new ZipObserver<T1>(_gate, this, 0, d1);
                base.Queues[0] = _observer1.Values;

                var d2 = new SingleAssignmentDisposable();
                disposables[1] = d2;
                _observer2 = new ZipObserver<T2>(_gate, this, 1, d2);
                base.Queues[1] = _observer2.Values;

                var d3 = new SingleAssignmentDisposable();
                disposables[2] = d3;
                _observer3 = new ZipObserver<T3>(_gate, this, 2, d3);
                base.Queues[2] = _observer3.Values;

                d1.Disposable = source1.SubscribeSafe(_observer1);
                d2.Disposable = source2.SubscribeSafe(_observer2);
                d3.Disposable = source3.SubscribeSafe(_observer3);

                disposables[3] = Disposable.Create(() =>
                {
                    _observer1.Values.Clear();
                    _observer2.Values.Clear();
                    _observer3.Values.Clear();
                });

                return StableCompositeDisposable.Create(disposables);
            }

            protected override TResult GetResult() => _resultSelector(_observer1.Values.Dequeue(), _observer2.Values.Dequeue(), _observer3.Values.Dequeue());
        }
    }

    internal sealed class Zip<T1, T2, T3, T4, TResult> : Producer<TResult, Zip<T1, T2, T3, T4, TResult>._>
    {
        private readonly IObservable<T1> _source1;
        private readonly IObservable<T2> _source2;
        private readonly IObservable<T3> _source3;
        private readonly IObservable<T4> _source4;
        private readonly Func<T1, T2, T3, T4, TResult> _resultSelector;

        public Zip(IObservable<T1> source1, IObservable<T2> source2, IObservable<T3> source3, IObservable<T4> source4, Func<T1, T2, T3, T4, TResult> resultSelector)
        {
            _source1 = source1;
            _source2 = source2;
            _source3 = source3;
            _source4 = source4;
            _resultSelector = resultSelector;
        }

        protected override _ CreateSink(IObserver<TResult> observer, IDisposable cancel) => new _(_resultSelector, observer, cancel);

        protected override IDisposable Run(_ sink) => sink.Run(_source1, _source2, _source3, _source4);

        internal sealed class _ : ZipSink<TResult>
        {
            private readonly Func<T1, T2, T3, T4, TResult> _resultSelector;

            public _(Func<T1, T2, T3, T4, TResult> resultSelector, IObserver<TResult> observer, IDisposable cancel)
                : base(4, observer, cancel)
            {
                _resultSelector = resultSelector;
            }

            private ZipObserver<T1> _observer1;
            private ZipObserver<T2> _observer2;
            private ZipObserver<T3> _observer3;
            private ZipObserver<T4> _observer4;

            public IDisposable Run(IObservable<T1> source1, IObservable<T2> source2, IObservable<T3> source3, IObservable<T4> source4)
            {
                var disposables = new IDisposable[5];

                var d1 = new SingleAssignmentDisposable();
                disposables[0] = d1;
                _observer1 = new ZipObserver<T1>(_gate, this, 0, d1);
                base.Queues[0] = _observer1.Values;

                var d2 = new SingleAssignmentDisposable();
                disposables[1] = d2;
                _observer2 = new ZipObserver<T2>(_gate, this, 1, d2);
                base.Queues[1] = _observer2.Values;

                var d3 = new SingleAssignmentDisposable();
                disposables[2] = d3;
                _observer3 = new ZipObserver<T3>(_gate, this, 2, d3);
                base.Queues[2] = _observer3.Values;

                var d4 = new SingleAssignmentDisposable();
                disposables[3] = d4;
                _observer4 = new ZipObserver<T4>(_gate, this, 3, d4);
                base.Queues[3] = _observer4.Values;

                d1.Disposable = source1.SubscribeSafe(_observer1);
                d2.Disposable = source2.SubscribeSafe(_observer2);
                d3.Disposable = source3.SubscribeSafe(_observer3);
                d4.Disposable = source4.SubscribeSafe(_observer4);

                disposables[4] = Disposable.Create(() =>
                {
                    _observer1.Values.Clear();
                    _observer2.Values.Clear();
                    _observer3.Values.Clear();
                    _observer4.Values.Clear();
                });

                return StableCompositeDisposable.Create(disposables);
            }

            protected override TResult GetResult() => _resultSelector(_observer1.Values.Dequeue(), _observer2.Values.Dequeue(), _observer3.Values.Dequeue(), _observer4.Values.Dequeue());
        }
    }

    internal sealed class Zip<T1, T2, T3, T4, T5, TResult> : Producer<TResult, Zip<T1, T2, T3, T4, T5, TResult>._>
    {
        private readonly IObservable<T1> _source1;
        private readonly IObservable<T2> _source2;
        private readonly IObservable<T3> _source3;
        private readonly IObservable<T4> _source4;
        private readonly IObservable<T5> _source5;
        private readonly Func<T1, T2, T3, T4, T5, TResult> _resultSelector;

        public Zip(IObservable<T1> source1, IObservable<T2> source2, IObservable<T3> source3, IObservable<T4> source4, IObservable<T5> source5, Func<T1, T2, T3, T4, T5, TResult> resultSelector)
        {
            _source1 = source1;
            _source2 = source2;
            _source3 = source3;
            _source4 = source4;
            _source5 = source5;
            _resultSelector = resultSelector;
        }

        protected override _ CreateSink(IObserver<TResult> observer, IDisposable cancel) => new _(_resultSelector, observer, cancel);

        protected override IDisposable Run(_ sink) => sink.Run(_source1, _source2, _source3, _source4, _source5);

        internal sealed class _ : ZipSink<TResult>
        {
            private readonly Func<T1, T2, T3, T4, T5, TResult> _resultSelector;

            public _(Func<T1, T2, T3, T4, T5, TResult> resultSelector, IObserver<TResult> observer, IDisposable cancel)
                : base(5, observer, cancel)
            {
                _resultSelector = resultSelector;
            }

            private ZipObserver<T1> _observer1;
            private ZipObserver<T2> _observer2;
            private ZipObserver<T3> _observer3;
            private ZipObserver<T4> _observer4;
            private ZipObserver<T5> _observer5;

            public IDisposable Run(IObservable<T1> source1, IObservable<T2> source2, IObservable<T3> source3, IObservable<T4> source4, IObservable<T5> source5)
            {
                var disposables = new IDisposable[6];

                var d1 = new SingleAssignmentDisposable();
                disposables[0] = d1;
                _observer1 = new ZipObserver<T1>(_gate, this, 0, d1);
                base.Queues[0] = _observer1.Values;

                var d2 = new SingleAssignmentDisposable();
                disposables[1] = d2;
                _observer2 = new ZipObserver<T2>(_gate, this, 1, d2);
                base.Queues[1] = _observer2.Values;

                var d3 = new SingleAssignmentDisposable();
                disposables[2] = d3;
                _observer3 = new ZipObserver<T3>(_gate, this, 2, d3);
                base.Queues[2] = _observer3.Values;

                var d4 = new SingleAssignmentDisposable();
                disposables[3] = d4;
                _observer4 = new ZipObserver<T4>(_gate, this, 3, d4);
                base.Queues[3] = _observer4.Values;

                var d5 = new SingleAssignmentDisposable();
                disposables[4] = d5;
                _observer5 = new ZipObserver<T5>(_gate, this, 4, d5);
                base.Queues[4] = _observer5.Values;

                d1.Disposable = source1.SubscribeSafe(_observer1);
                d2.Disposable = source2.SubscribeSafe(_observer2);
                d3.Disposable = source3.SubscribeSafe(_observer3);
                d4.Disposable = source4.SubscribeSafe(_observer4);
                d5.Disposable = source5.SubscribeSafe(_observer5);

                disposables[5] = Disposable.Create(() =>
                {
                    _observer1.Values.Clear();
                    _observer2.Values.Clear();
                    _observer3.Values.Clear();
                    _observer4.Values.Clear();
                    _observer5.Values.Clear();
                });

                return StableCompositeDisposable.Create(disposables);
            }

            protected override TResult GetResult() => _resultSelector(_observer1.Values.Dequeue(), _observer2.Values.Dequeue(), _observer3.Values.Dequeue(), _observer4.Values.Dequeue(), _observer5.Values.Dequeue());
        }
    }

    internal sealed class Zip<T1, T2, T3, T4, T5, T6, TResult> : Producer<TResult, Zip<T1, T2, T3, T4, T5, T6, TResult>._>
    {
        private readonly IObservable<T1> _source1;
        private readonly IObservable<T2> _source2;
        private readonly IObservable<T3> _source3;
        private readonly IObservable<T4> _source4;
        private readonly IObservable<T5> _source5;
        private readonly IObservable<T6> _source6;
        private readonly Func<T1, T2, T3, T4, T5, T6, TResult> _resultSelector;

        public Zip(IObservable<T1> source1, IObservable<T2> source2, IObservable<T3> source3, IObservable<T4> source4, IObservable<T5> source5, IObservable<T6> source6, Func<T1, T2, T3, T4, T5, T6, TResult> resultSelector)
        {
            _source1 = source1;
            _source2 = source2;
            _source3 = source3;
            _source4 = source4;
            _source5 = source5;
            _source6 = source6;
            _resultSelector = resultSelector;
        }

        protected override _ CreateSink(IObserver<TResult> observer, IDisposable cancel) => new _(_resultSelector, observer, cancel);

        protected override IDisposable Run(_ sink) => sink.Run(_source1, _source2, _source3, _source4, _source5, _source6);

        internal sealed class _ : ZipSink<TResult>
        {
            private readonly Func<T1, T2, T3, T4, T5, T6, TResult> _resultSelector;

            public _(Func<T1, T2, T3, T4, T5, T6, TResult> resultSelector, IObserver<TResult> observer, IDisposable cancel)
                : base(6, observer, cancel)
            {
                _resultSelector = resultSelector;
            }

            private ZipObserver<T1> _observer1;
            private ZipObserver<T2> _observer2;
            private ZipObserver<T3> _observer3;
            private ZipObserver<T4> _observer4;
            private ZipObserver<T5> _observer5;
            private ZipObserver<T6> _observer6;

            public IDisposable Run(IObservable<T1> source1, IObservable<T2> source2, IObservable<T3> source3, IObservable<T4> source4, IObservable<T5> source5, IObservable<T6> source6)
            {
                var disposables = new IDisposable[7];

                var d1 = new SingleAssignmentDisposable();
                disposables[0] = d1;
                _observer1 = new ZipObserver<T1>(_gate, this, 0, d1);
                base.Queues[0] = _observer1.Values;

                var d2 = new SingleAssignmentDisposable();
                disposables[1] = d2;
                _observer2 = new ZipObserver<T2>(_gate, this, 1, d2);
                base.Queues[1] = _observer2.Values;

                var d3 = new SingleAssignmentDisposable();
                disposables[2] = d3;
                _observer3 = new ZipObserver<T3>(_gate, this, 2, d3);
                base.Queues[2] = _observer3.Values;

                var d4 = new SingleAssignmentDisposable();
                disposables[3] = d4;
                _observer4 = new ZipObserver<T4>(_gate, this, 3, d4);
                base.Queues[3] = _observer4.Values;

                var d5 = new SingleAssignmentDisposable();
                disposables[4] = d5;
                _observer5 = new ZipObserver<T5>(_gate, this, 4, d5);
                base.Queues[4] = _observer5.Values;

                var d6 = new SingleAssignmentDisposable();
                disposables[5] = d6;
                _observer6 = new ZipObserver<T6>(_gate, this, 5, d6);
                base.Queues[5] = _observer6.Values;

                d1.Disposable = source1.SubscribeSafe(_observer1);
                d2.Disposable = source2.SubscribeSafe(_observer2);
                d3.Disposable = source3.SubscribeSafe(_observer3);
                d4.Disposable = source4.SubscribeSafe(_observer4);
                d5.Disposable = source5.SubscribeSafe(_observer5);
                d6.Disposable = source6.SubscribeSafe(_observer6);

                disposables[6] = Disposable.Create(() =>
                {
                    _observer1.Values.Clear();
                    _observer2.Values.Clear();
                    _observer3.Values.Clear();
                    _observer4.Values.Clear();
                    _observer5.Values.Clear();
                    _observer6.Values.Clear();
                });

                return StableCompositeDisposable.Create(disposables);
            }

            protected override TResult GetResult() => _resultSelector(_observer1.Values.Dequeue(), _observer2.Values.Dequeue(), _observer3.Values.Dequeue(), _observer4.Values.Dequeue(), _observer5.Values.Dequeue(), _observer6.Values.Dequeue());
        }
    }

    internal sealed class Zip<T1, T2, T3, T4, T5, T6, T7, TResult> : Producer<TResult, Zip<T1, T2, T3, T4, T5, T6, T7, TResult>._>
    {
        private readonly IObservable<T1> _source1;
        private readonly IObservable<T2> _source2;
        private readonly IObservable<T3> _source3;
        private readonly IObservable<T4> _source4;
        private readonly IObservable<T5> _source5;
        private readonly IObservable<T6> _source6;
        private readonly IObservable<T7> _source7;
        private readonly Func<T1, T2, T3, T4, T5, T6, T7, TResult> _resultSelector;

        public Zip(IObservable<T1> source1, IObservable<T2> source2, IObservable<T3> source3, IObservable<T4> source4, IObservable<T5> source5, IObservable<T6> source6, IObservable<T7> source7, Func<T1, T2, T3, T4, T5, T6, T7, TResult> resultSelector)
        {
            _source1 = source1;
            _source2 = source2;
            _source3 = source3;
            _source4 = source4;
            _source5 = source5;
            _source6 = source6;
            _source7 = source7;
            _resultSelector = resultSelector;
        }

        protected override _ CreateSink(IObserver<TResult> observer, IDisposable cancel) => new _(_resultSelector, observer, cancel);

        protected override IDisposable Run(_ sink) => sink.Run(_source1, _source2, _source3, _source4, _source5, _source6, _source7);

        internal sealed class _ : ZipSink<TResult>
        {
            private readonly Func<T1, T2, T3, T4, T5, T6, T7, TResult> _resultSelector;

            public _(Func<T1, T2, T3, T4, T5, T6, T7, TResult> resultSelector, IObserver<TResult> observer, IDisposable cancel)
                : base(7, observer, cancel)
            {
                _resultSelector = resultSelector;
            }

            private ZipObserver<T1> _observer1;
            private ZipObserver<T2> _observer2;
            private ZipObserver<T3> _observer3;
            private ZipObserver<T4> _observer4;
            private ZipObserver<T5> _observer5;
            private ZipObserver<T6> _observer6;
            private ZipObserver<T7> _observer7;

            public IDisposable Run(IObservable<T1> source1, IObservable<T2> source2, IObservable<T3> source3, IObservable<T4> source4, IObservable<T5> source5, IObservable<T6> source6, IObservable<T7> source7)
            {
                var disposables = new IDisposable[8];

                var d1 = new SingleAssignmentDisposable();
                disposables[0] = d1;
                _observer1 = new ZipObserver<T1>(_gate, this, 0, d1);
                base.Queues[0] = _observer1.Values;

                var d2 = new SingleAssignmentDisposable();
                disposables[1] = d2;
                _observer2 = new ZipObserver<T2>(_gate, this, 1, d2);
                base.Queues[1] = _observer2.Values;

                var d3 = new SingleAssignmentDisposable();
                disposables[2] = d3;
                _observer3 = new ZipObserver<T3>(_gate, this, 2, d3);
                base.Queues[2] = _observer3.Values;

                var d4 = new SingleAssignmentDisposable();
                disposables[3] = d4;
                _observer4 = new ZipObserver<T4>(_gate, this, 3, d4);
                base.Queues[3] = _observer4.Values;

                var d5 = new SingleAssignmentDisposable();
                disposables[4] = d5;
                _observer5 = new ZipObserver<T5>(_gate, this, 4, d5);
                base.Queues[4] = _observer5.Values;

                var d6 = new SingleAssignmentDisposable();
                disposables[5] = d6;
                _observer6 = new ZipObserver<T6>(_gate, this, 5, d6);
                base.Queues[5] = _observer6.Values;

                var d7 = new SingleAssignmentDisposable();
                disposables[6] = d7;
                _observer7 = new ZipObserver<T7>(_gate, this, 6, d7);
                base.Queues[6] = _observer7.Values;

                d1.Disposable = source1.SubscribeSafe(_observer1);
                d2.Disposable = source2.SubscribeSafe(_observer2);
                d3.Disposable = source3.SubscribeSafe(_observer3);
                d4.Disposable = source4.SubscribeSafe(_observer4);
                d5.Disposable = source5.SubscribeSafe(_observer5);
                d6.Disposable = source6.SubscribeSafe(_observer6);
                d7.Disposable = source7.SubscribeSafe(_observer7);

                disposables[7] = Disposable.Create(() =>
                {
                    _observer1.Values.Clear();
                    _observer2.Values.Clear();
                    _observer3.Values.Clear();
                    _observer4.Values.Clear();
                    _observer5.Values.Clear();
                    _observer6.Values.Clear();
                    _observer7.Values.Clear();
                });

                return StableCompositeDisposable.Create(disposables);
            }

            protected override TResult GetResult() => _resultSelector(_observer1.Values.Dequeue(), _observer2.Values.Dequeue(), _observer3.Values.Dequeue(), _observer4.Values.Dequeue(), _observer5.Values.Dequeue(), _observer6.Values.Dequeue(), _observer7.Values.Dequeue());
        }
    }

    internal sealed class Zip<T1, T2, T3, T4, T5, T6, T7, T8, TResult> : Producer<TResult, Zip<T1, T2, T3, T4, T5, T6, T7, T8, TResult>._>
    {
        private readonly IObservable<T1> _source1;
        private readonly IObservable<T2> _source2;
        private readonly IObservable<T3> _source3;
        private readonly IObservable<T4> _source4;
        private readonly IObservable<T5> _source5;
        private readonly IObservable<T6> _source6;
        private readonly IObservable<T7> _source7;
        private readonly IObservable<T8> _source8;
        private readonly Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult> _resultSelector;

        public Zip(IObservable<T1> source1, IObservable<T2> source2, IObservable<T3> source3, IObservable<T4> source4, IObservable<T5> source5, IObservable<T6> source6, IObservable<T7> source7, IObservable<T8> source8, Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult> resultSelector)
        {
            _source1 = source1;
            _source2 = source2;
            _source3 = source3;
            _source4 = source4;
            _source5 = source5;
            _source6 = source6;
            _source7 = source7;
            _source8 = source8;
            _resultSelector = resultSelector;
        }

        protected override _ CreateSink(IObserver<TResult> observer, IDisposable cancel) => new _(_resultSelector, observer, cancel);

        protected override IDisposable Run(_ sink) => sink.Run(_source1, _source2, _source3, _source4, _source5, _source6, _source7, _source8);

        internal sealed class _ : ZipSink<TResult>
        {
            private readonly Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult> _resultSelector;

            public _(Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult> resultSelector, IObserver<TResult> observer, IDisposable cancel)
                : base(8, observer, cancel)
            {
                _resultSelector = resultSelector;
            }

            private ZipObserver<T1> _observer1;
            private ZipObserver<T2> _observer2;
            private ZipObserver<T3> _observer3;
            private ZipObserver<T4> _observer4;
            private ZipObserver<T5> _observer5;
            private ZipObserver<T6> _observer6;
            private ZipObserver<T7> _observer7;
            private ZipObserver<T8> _observer8;

            public IDisposable Run(IObservable<T1> source1, IObservable<T2> source2, IObservable<T3> source3, IObservable<T4> source4, IObservable<T5> source5, IObservable<T6> source6, IObservable<T7> source7, IObservable<T8> source8)
            {
                var disposables = new IDisposable[9];

                var d1 = new SingleAssignmentDisposable();
                disposables[0] = d1;
                _observer1 = new ZipObserver<T1>(_gate, this, 0, d1);
                base.Queues[0] = _observer1.Values;

                var d2 = new SingleAssignmentDisposable();
                disposables[1] = d2;
                _observer2 = new ZipObserver<T2>(_gate, this, 1, d2);
                base.Queues[1] = _observer2.Values;

                var d3 = new SingleAssignmentDisposable();
                disposables[2] = d3;
                _observer3 = new ZipObserver<T3>(_gate, this, 2, d3);
                base.Queues[2] = _observer3.Values;

                var d4 = new SingleAssignmentDisposable();
                disposables[3] = d4;
                _observer4 = new ZipObserver<T4>(_gate, this, 3, d4);
                base.Queues[3] = _observer4.Values;

                var d5 = new SingleAssignmentDisposable();
                disposables[4] = d5;
                _observer5 = new ZipObserver<T5>(_gate, this, 4, d5);
                base.Queues[4] = _observer5.Values;

                var d6 = new SingleAssignmentDisposable();
                disposables[5] = d6;
                _observer6 = new ZipObserver<T6>(_gate, this, 5, d6);
                base.Queues[5] = _observer6.Values;

                var d7 = new SingleAssignmentDisposable();
                disposables[6] = d7;
                _observer7 = new ZipObserver<T7>(_gate, this, 6, d7);
                base.Queues[6] = _observer7.Values;

                var d8 = new SingleAssignmentDisposable();
                disposables[7] = d8;
                _observer8 = new ZipObserver<T8>(_gate, this, 7, d8);
                base.Queues[7] = _observer8.Values;

                d1.Disposable = source1.SubscribeSafe(_observer1);
                d2.Disposable = source2.SubscribeSafe(_observer2);
                d3.Disposable = source3.SubscribeSafe(_observer3);
                d4.Disposable = source4.SubscribeSafe(_observer4);
                d5.Disposable = source5.SubscribeSafe(_observer5);
                d6.Disposable = source6.SubscribeSafe(_observer6);
                d7.Disposable = source7.SubscribeSafe(_observer7);
                d8.Disposable = source8.SubscribeSafe(_observer8);

                disposables[8] = Disposable.Create(() =>
                {
                    _observer1.Values.Clear();
                    _observer2.Values.Clear();
                    _observer3.Values.Clear();
                    _observer4.Values.Clear();
                    _observer5.Values.Clear();
                    _observer6.Values.Clear();
                    _observer7.Values.Clear();
                    _observer8.Values.Clear();
                });

                return StableCompositeDisposable.Create(disposables);
            }

            protected override TResult GetResult() => _resultSelector(_observer1.Values.Dequeue(), _observer2.Values.Dequeue(), _observer3.Values.Dequeue(), _observer4.Values.Dequeue(), _observer5.Values.Dequeue(), _observer6.Values.Dequeue(), _observer7.Values.Dequeue(), _observer8.Values.Dequeue());
        }
    }

    internal sealed class Zip<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> : Producer<TResult, Zip<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>._>
    {
        private readonly IObservable<T1> _source1;
        private readonly IObservable<T2> _source2;
        private readonly IObservable<T3> _source3;
        private readonly IObservable<T4> _source4;
        private readonly IObservable<T5> _source5;
        private readonly IObservable<T6> _source6;
        private readonly IObservable<T7> _source7;
        private readonly IObservable<T8> _source8;
        private readonly IObservable<T9> _source9;
        private readonly Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> _resultSelector;

        public Zip(IObservable<T1> source1, IObservable<T2> source2, IObservable<T3> source3, IObservable<T4> source4, IObservable<T5> source5, IObservable<T6> source6, IObservable<T7> source7, IObservable<T8> source8, IObservable<T9> source9, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> resultSelector)
        {
            _source1 = source1;
            _source2 = source2;
            _source3 = source3;
            _source4 = source4;
            _source5 = source5;
            _source6 = source6;
            _source7 = source7;
            _source8 = source8;
            _source9 = source9;
            _resultSelector = resultSelector;
        }

        protected override _ CreateSink(IObserver<TResult> observer, IDisposable cancel) => new _(_resultSelector, observer, cancel);

        protected override IDisposable Run(_ sink) => sink.Run(_source1, _source2, _source3, _source4, _source5, _source6, _source7, _source8, _source9);

        internal sealed class _ : ZipSink<TResult>
        {
            private readonly Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> _resultSelector;

            public _(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> resultSelector, IObserver<TResult> observer, IDisposable cancel)
                : base(9, observer, cancel)
            {
                _resultSelector = resultSelector;
            }

            private ZipObserver<T1> _observer1;
            private ZipObserver<T2> _observer2;
            private ZipObserver<T3> _observer3;
            private ZipObserver<T4> _observer4;
            private ZipObserver<T5> _observer5;
            private ZipObserver<T6> _observer6;
            private ZipObserver<T7> _observer7;
            private ZipObserver<T8> _observer8;
            private ZipObserver<T9> _observer9;

            public IDisposable Run(IObservable<T1> source1, IObservable<T2> source2, IObservable<T3> source3, IObservable<T4> source4, IObservable<T5> source5, IObservable<T6> source6, IObservable<T7> source7, IObservable<T8> source8, IObservable<T9> source9)
            {
                var disposables = new IDisposable[10];

                var d1 = new SingleAssignmentDisposable();
                disposables[0] = d1;
                _observer1 = new ZipObserver<T1>(_gate, this, 0, d1);
                base.Queues[0] = _observer1.Values;

                var d2 = new SingleAssignmentDisposable();
                disposables[1] = d2;
                _observer2 = new ZipObserver<T2>(_gate, this, 1, d2);
                base.Queues[1] = _observer2.Values;

                var d3 = new SingleAssignmentDisposable();
                disposables[2] = d3;
                _observer3 = new ZipObserver<T3>(_gate, this, 2, d3);
                base.Queues[2] = _observer3.Values;

                var d4 = new SingleAssignmentDisposable();
                disposables[3] = d4;
                _observer4 = new ZipObserver<T4>(_gate, this, 3, d4);
                base.Queues[3] = _observer4.Values;

                var d5 = new SingleAssignmentDisposable();
                disposables[4] = d5;
                _observer5 = new ZipObserver<T5>(_gate, this, 4, d5);
                base.Queues[4] = _observer5.Values;

                var d6 = new SingleAssignmentDisposable();
                disposables[5] = d6;
                _observer6 = new ZipObserver<T6>(_gate, this, 5, d6);
                base.Queues[5] = _observer6.Values;

                var d7 = new SingleAssignmentDisposable();
                disposables[6] = d7;
                _observer7 = new ZipObserver<T7>(_gate, this, 6, d7);
                base.Queues[6] = _observer7.Values;

                var d8 = new SingleAssignmentDisposable();
                disposables[7] = d8;
                _observer8 = new ZipObserver<T8>(_gate, this, 7, d8);
                base.Queues[7] = _observer8.Values;

                var d9 = new SingleAssignmentDisposable();
                disposables[8] = d9;
                _observer9 = new ZipObserver<T9>(_gate, this, 8, d9);
                base.Queues[8] = _observer9.Values;

                d1.Disposable = source1.SubscribeSafe(_observer1);
                d2.Disposable = source2.SubscribeSafe(_observer2);
                d3.Disposable = source3.SubscribeSafe(_observer3);
                d4.Disposable = source4.SubscribeSafe(_observer4);
                d5.Disposable = source5.SubscribeSafe(_observer5);
                d6.Disposable = source6.SubscribeSafe(_observer6);
                d7.Disposable = source7.SubscribeSafe(_observer7);
                d8.Disposable = source8.SubscribeSafe(_observer8);
                d9.Disposable = source9.SubscribeSafe(_observer9);

                disposables[9] = Disposable.Create(() =>
                {
                    _observer1.Values.Clear();
                    _observer2.Values.Clear();
                    _observer3.Values.Clear();
                    _observer4.Values.Clear();
                    _observer5.Values.Clear();
                    _observer6.Values.Clear();
                    _observer7.Values.Clear();
                    _observer8.Values.Clear();
                    _observer9.Values.Clear();
                });

                return StableCompositeDisposable.Create(disposables);
            }

            protected override TResult GetResult() => _resultSelector(_observer1.Values.Dequeue(), _observer2.Values.Dequeue(), _observer3.Values.Dequeue(), _observer4.Values.Dequeue(), _observer5.Values.Dequeue(), _observer6.Values.Dequeue(), _observer7.Values.Dequeue(), _observer8.Values.Dequeue(), _observer9.Values.Dequeue());
        }
    }

    internal sealed class Zip<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> : Producer<TResult, Zip<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>._>
    {
        private readonly IObservable<T1> _source1;
        private readonly IObservable<T2> _source2;
        private readonly IObservable<T3> _source3;
        private readonly IObservable<T4> _source4;
        private readonly IObservable<T5> _source5;
        private readonly IObservable<T6> _source6;
        private readonly IObservable<T7> _source7;
        private readonly IObservable<T8> _source8;
        private readonly IObservable<T9> _source9;
        private readonly IObservable<T10> _source10;
        private readonly Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> _resultSelector;

        public Zip(IObservable<T1> source1, IObservable<T2> source2, IObservable<T3> source3, IObservable<T4> source4, IObservable<T5> source5, IObservable<T6> source6, IObservable<T7> source7, IObservable<T8> source8, IObservable<T9> source9, IObservable<T10> source10, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> resultSelector)
        {
            _source1 = source1;
            _source2 = source2;
            _source3 = source3;
            _source4 = source4;
            _source5 = source5;
            _source6 = source6;
            _source7 = source7;
            _source8 = source8;
            _source9 = source9;
            _source10 = source10;
            _resultSelector = resultSelector;
        }

        protected override _ CreateSink(IObserver<TResult> observer, IDisposable cancel) => new _(_resultSelector, observer, cancel);

        protected override IDisposable Run(_ sink) => sink.Run(_source1, _source2, _source3, _source4, _source5, _source6, _source7, _source8, _source9, _source10);

        internal sealed class _ : ZipSink<TResult>
        {
            private readonly Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> _resultSelector;

            public _(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> resultSelector, IObserver<TResult> observer, IDisposable cancel)
                : base(10, observer, cancel)
            {
                _resultSelector = resultSelector;
            }

            private ZipObserver<T1> _observer1;
            private ZipObserver<T2> _observer2;
            private ZipObserver<T3> _observer3;
            private ZipObserver<T4> _observer4;
            private ZipObserver<T5> _observer5;
            private ZipObserver<T6> _observer6;
            private ZipObserver<T7> _observer7;
            private ZipObserver<T8> _observer8;
            private ZipObserver<T9> _observer9;
            private ZipObserver<T10> _observer10;

            public IDisposable Run(IObservable<T1> source1, IObservable<T2> source2, IObservable<T3> source3, IObservable<T4> source4, IObservable<T5> source5, IObservable<T6> source6, IObservable<T7> source7, IObservable<T8> source8, IObservable<T9> source9, IObservable<T10> source10)
            {
                var disposables = new IDisposable[11];

                var d1 = new SingleAssignmentDisposable();
                disposables[0] = d1;
                _observer1 = new ZipObserver<T1>(_gate, this, 0, d1);
                base.Queues[0] = _observer1.Values;

                var d2 = new SingleAssignmentDisposable();
                disposables[1] = d2;
                _observer2 = new ZipObserver<T2>(_gate, this, 1, d2);
                base.Queues[1] = _observer2.Values;

                var d3 = new SingleAssignmentDisposable();
                disposables[2] = d3;
                _observer3 = new ZipObserver<T3>(_gate, this, 2, d3);
                base.Queues[2] = _observer3.Values;

                var d4 = new SingleAssignmentDisposable();
                disposables[3] = d4;
                _observer4 = new ZipObserver<T4>(_gate, this, 3, d4);
                base.Queues[3] = _observer4.Values;

                var d5 = new SingleAssignmentDisposable();
                disposables[4] = d5;
                _observer5 = new ZipObserver<T5>(_gate, this, 4, d5);
                base.Queues[4] = _observer5.Values;

                var d6 = new SingleAssignmentDisposable();
                disposables[5] = d6;
                _observer6 = new ZipObserver<T6>(_gate, this, 5, d6);
                base.Queues[5] = _observer6.Values;

                var d7 = new SingleAssignmentDisposable();
                disposables[6] = d7;
                _observer7 = new ZipObserver<T7>(_gate, this, 6, d7);
                base.Queues[6] = _observer7.Values;

                var d8 = new SingleAssignmentDisposable();
                disposables[7] = d8;
                _observer8 = new ZipObserver<T8>(_gate, this, 7, d8);
                base.Queues[7] = _observer8.Values;

                var d9 = new SingleAssignmentDisposable();
                disposables[8] = d9;
                _observer9 = new ZipObserver<T9>(_gate, this, 8, d9);
                base.Queues[8] = _observer9.Values;

                var d10 = new SingleAssignmentDisposable();
                disposables[9] = d10;
                _observer10 = new ZipObserver<T10>(_gate, this, 9, d10);
                base.Queues[9] = _observer10.Values;

                d1.Disposable = source1.SubscribeSafe(_observer1);
                d2.Disposable = source2.SubscribeSafe(_observer2);
                d3.Disposable = source3.SubscribeSafe(_observer3);
                d4.Disposable = source4.SubscribeSafe(_observer4);
                d5.Disposable = source5.SubscribeSafe(_observer5);
                d6.Disposable = source6.SubscribeSafe(_observer6);
                d7.Disposable = source7.SubscribeSafe(_observer7);
                d8.Disposable = source8.SubscribeSafe(_observer8);
                d9.Disposable = source9.SubscribeSafe(_observer9);
                d10.Disposable = source10.SubscribeSafe(_observer10);

                disposables[10] = Disposable.Create(() =>
                {
                    _observer1.Values.Clear();
                    _observer2.Values.Clear();
                    _observer3.Values.Clear();
                    _observer4.Values.Clear();
                    _observer5.Values.Clear();
                    _observer6.Values.Clear();
                    _observer7.Values.Clear();
                    _observer8.Values.Clear();
                    _observer9.Values.Clear();
                    _observer10.Values.Clear();
                });

                return StableCompositeDisposable.Create(disposables);
            }

            protected override TResult GetResult() => _resultSelector(_observer1.Values.Dequeue(), _observer2.Values.Dequeue(), _observer3.Values.Dequeue(), _observer4.Values.Dequeue(), _observer5.Values.Dequeue(), _observer6.Values.Dequeue(), _observer7.Values.Dequeue(), _observer8.Values.Dequeue(), _observer9.Values.Dequeue(), _observer10.Values.Dequeue());
        }
    }

    internal sealed class Zip<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> : Producer<TResult, Zip<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>._>
    {
        private readonly IObservable<T1> _source1;
        private readonly IObservable<T2> _source2;
        private readonly IObservable<T3> _source3;
        private readonly IObservable<T4> _source4;
        private readonly IObservable<T5> _source5;
        private readonly IObservable<T6> _source6;
        private readonly IObservable<T7> _source7;
        private readonly IObservable<T8> _source8;
        private readonly IObservable<T9> _source9;
        private readonly IObservable<T10> _source10;
        private readonly IObservable<T11> _source11;
        private readonly Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> _resultSelector;

        public Zip(IObservable<T1> source1, IObservable<T2> source2, IObservable<T3> source3, IObservable<T4> source4, IObservable<T5> source5, IObservable<T6> source6, IObservable<T7> source7, IObservable<T8> source8, IObservable<T9> source9, IObservable<T10> source10, IObservable<T11> source11, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> resultSelector)
        {
            _source1 = source1;
            _source2 = source2;
            _source3 = source3;
            _source4 = source4;
            _source5 = source5;
            _source6 = source6;
            _source7 = source7;
            _source8 = source8;
            _source9 = source9;
            _source10 = source10;
            _source11 = source11;
            _resultSelector = resultSelector;
        }

        protected override _ CreateSink(IObserver<TResult> observer, IDisposable cancel) => new _(_resultSelector, observer, cancel);

        protected override IDisposable Run(_ sink) => sink.Run(_source1, _source2, _source3, _source4, _source5, _source6, _source7, _source8, _source9, _source10, _source11);

        internal sealed class _ : ZipSink<TResult>
        {
            private readonly Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> _resultSelector;

            public _(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> resultSelector, IObserver<TResult> observer, IDisposable cancel)
                : base(11, observer, cancel)
            {
                _resultSelector = resultSelector;
            }

            private ZipObserver<T1> _observer1;
            private ZipObserver<T2> _observer2;
            private ZipObserver<T3> _observer3;
            private ZipObserver<T4> _observer4;
            private ZipObserver<T5> _observer5;
            private ZipObserver<T6> _observer6;
            private ZipObserver<T7> _observer7;
            private ZipObserver<T8> _observer8;
            private ZipObserver<T9> _observer9;
            private ZipObserver<T10> _observer10;
            private ZipObserver<T11> _observer11;

            public IDisposable Run(IObservable<T1> source1, IObservable<T2> source2, IObservable<T3> source3, IObservable<T4> source4, IObservable<T5> source5, IObservable<T6> source6, IObservable<T7> source7, IObservable<T8> source8, IObservable<T9> source9, IObservable<T10> source10, IObservable<T11> source11)
            {
                var disposables = new IDisposable[12];

                var d1 = new SingleAssignmentDisposable();
                disposables[0] = d1;
                _observer1 = new ZipObserver<T1>(_gate, this, 0, d1);
                base.Queues[0] = _observer1.Values;

                var d2 = new SingleAssignmentDisposable();
                disposables[1] = d2;
                _observer2 = new ZipObserver<T2>(_gate, this, 1, d2);
                base.Queues[1] = _observer2.Values;

                var d3 = new SingleAssignmentDisposable();
                disposables[2] = d3;
                _observer3 = new ZipObserver<T3>(_gate, this, 2, d3);
                base.Queues[2] = _observer3.Values;

                var d4 = new SingleAssignmentDisposable();
                disposables[3] = d4;
                _observer4 = new ZipObserver<T4>(_gate, this, 3, d4);
                base.Queues[3] = _observer4.Values;

                var d5 = new SingleAssignmentDisposable();
                disposables[4] = d5;
                _observer5 = new ZipObserver<T5>(_gate, this, 4, d5);
                base.Queues[4] = _observer5.Values;

                var d6 = new SingleAssignmentDisposable();
                disposables[5] = d6;
                _observer6 = new ZipObserver<T6>(_gate, this, 5, d6);
                base.Queues[5] = _observer6.Values;

                var d7 = new SingleAssignmentDisposable();
                disposables[6] = d7;
                _observer7 = new ZipObserver<T7>(_gate, this, 6, d7);
                base.Queues[6] = _observer7.Values;

                var d8 = new SingleAssignmentDisposable();
                disposables[7] = d8;
                _observer8 = new ZipObserver<T8>(_gate, this, 7, d8);
                base.Queues[7] = _observer8.Values;

                var d9 = new SingleAssignmentDisposable();
                disposables[8] = d9;
                _observer9 = new ZipObserver<T9>(_gate, this, 8, d9);
                base.Queues[8] = _observer9.Values;

                var d10 = new SingleAssignmentDisposable();
                disposables[9] = d10;
                _observer10 = new ZipObserver<T10>(_gate, this, 9, d10);
                base.Queues[9] = _observer10.Values;

                var d11 = new SingleAssignmentDisposable();
                disposables[10] = d11;
                _observer11 = new ZipObserver<T11>(_gate, this, 10, d11);
                base.Queues[10] = _observer11.Values;

                d1.Disposable = source1.SubscribeSafe(_observer1);
                d2.Disposable = source2.SubscribeSafe(_observer2);
                d3.Disposable = source3.SubscribeSafe(_observer3);
                d4.Disposable = source4.SubscribeSafe(_observer4);
                d5.Disposable = source5.SubscribeSafe(_observer5);
                d6.Disposable = source6.SubscribeSafe(_observer6);
                d7.Disposable = source7.SubscribeSafe(_observer7);
                d8.Disposable = source8.SubscribeSafe(_observer8);
                d9.Disposable = source9.SubscribeSafe(_observer9);
                d10.Disposable = source10.SubscribeSafe(_observer10);
                d11.Disposable = source11.SubscribeSafe(_observer11);

                disposables[11] = Disposable.Create(() =>
                {
                    _observer1.Values.Clear();
                    _observer2.Values.Clear();
                    _observer3.Values.Clear();
                    _observer4.Values.Clear();
                    _observer5.Values.Clear();
                    _observer6.Values.Clear();
                    _observer7.Values.Clear();
                    _observer8.Values.Clear();
                    _observer9.Values.Clear();
                    _observer10.Values.Clear();
                    _observer11.Values.Clear();
                });

                return StableCompositeDisposable.Create(disposables);
            }

            protected override TResult GetResult() => _resultSelector(_observer1.Values.Dequeue(), _observer2.Values.Dequeue(), _observer3.Values.Dequeue(), _observer4.Values.Dequeue(), _observer5.Values.Dequeue(), _observer6.Values.Dequeue(), _observer7.Values.Dequeue(), _observer8.Values.Dequeue(), _observer9.Values.Dequeue(), _observer10.Values.Dequeue(), _observer11.Values.Dequeue());
        }
    }

    internal sealed class Zip<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> : Producer<TResult, Zip<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>._>
    {
        private readonly IObservable<T1> _source1;
        private readonly IObservable<T2> _source2;
        private readonly IObservable<T3> _source3;
        private readonly IObservable<T4> _source4;
        private readonly IObservable<T5> _source5;
        private readonly IObservable<T6> _source6;
        private readonly IObservable<T7> _source7;
        private readonly IObservable<T8> _source8;
        private readonly IObservable<T9> _source9;
        private readonly IObservable<T10> _source10;
        private readonly IObservable<T11> _source11;
        private readonly IObservable<T12> _source12;
        private readonly Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> _resultSelector;

        public Zip(IObservable<T1> source1, IObservable<T2> source2, IObservable<T3> source3, IObservable<T4> source4, IObservable<T5> source5, IObservable<T6> source6, IObservable<T7> source7, IObservable<T8> source8, IObservable<T9> source9, IObservable<T10> source10, IObservable<T11> source11, IObservable<T12> source12, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> resultSelector)
        {
            _source1 = source1;
            _source2 = source2;
            _source3 = source3;
            _source4 = source4;
            _source5 = source5;
            _source6 = source6;
            _source7 = source7;
            _source8 = source8;
            _source9 = source9;
            _source10 = source10;
            _source11 = source11;
            _source12 = source12;
            _resultSelector = resultSelector;
        }

        protected override _ CreateSink(IObserver<TResult> observer, IDisposable cancel) => new _(_resultSelector, observer, cancel);

        protected override IDisposable Run(_ sink) => sink.Run(_source1, _source2, _source3, _source4, _source5, _source6, _source7, _source8, _source9, _source10, _source11, _source12);

        internal sealed class _ : ZipSink<TResult>
        {
            private readonly Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> _resultSelector;

            public _(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> resultSelector, IObserver<TResult> observer, IDisposable cancel)
                : base(12, observer, cancel)
            {
                _resultSelector = resultSelector;
            }

            private ZipObserver<T1> _observer1;
            private ZipObserver<T2> _observer2;
            private ZipObserver<T3> _observer3;
            private ZipObserver<T4> _observer4;
            private ZipObserver<T5> _observer5;
            private ZipObserver<T6> _observer6;
            private ZipObserver<T7> _observer7;
            private ZipObserver<T8> _observer8;
            private ZipObserver<T9> _observer9;
            private ZipObserver<T10> _observer10;
            private ZipObserver<T11> _observer11;
            private ZipObserver<T12> _observer12;

            public IDisposable Run(IObservable<T1> source1, IObservable<T2> source2, IObservable<T3> source3, IObservable<T4> source4, IObservable<T5> source5, IObservable<T6> source6, IObservable<T7> source7, IObservable<T8> source8, IObservable<T9> source9, IObservable<T10> source10, IObservable<T11> source11, IObservable<T12> source12)
            {
                var disposables = new IDisposable[13];

                var d1 = new SingleAssignmentDisposable();
                disposables[0] = d1;
                _observer1 = new ZipObserver<T1>(_gate, this, 0, d1);
                base.Queues[0] = _observer1.Values;

                var d2 = new SingleAssignmentDisposable();
                disposables[1] = d2;
                _observer2 = new ZipObserver<T2>(_gate, this, 1, d2);
                base.Queues[1] = _observer2.Values;

                var d3 = new SingleAssignmentDisposable();
                disposables[2] = d3;
                _observer3 = new ZipObserver<T3>(_gate, this, 2, d3);
                base.Queues[2] = _observer3.Values;

                var d4 = new SingleAssignmentDisposable();
                disposables[3] = d4;
                _observer4 = new ZipObserver<T4>(_gate, this, 3, d4);
                base.Queues[3] = _observer4.Values;

                var d5 = new SingleAssignmentDisposable();
                disposables[4] = d5;
                _observer5 = new ZipObserver<T5>(_gate, this, 4, d5);
                base.Queues[4] = _observer5.Values;

                var d6 = new SingleAssignmentDisposable();
                disposables[5] = d6;
                _observer6 = new ZipObserver<T6>(_gate, this, 5, d6);
                base.Queues[5] = _observer6.Values;

                var d7 = new SingleAssignmentDisposable();
                disposables[6] = d7;
                _observer7 = new ZipObserver<T7>(_gate, this, 6, d7);
                base.Queues[6] = _observer7.Values;

                var d8 = new SingleAssignmentDisposable();
                disposables[7] = d8;
                _observer8 = new ZipObserver<T8>(_gate, this, 7, d8);
                base.Queues[7] = _observer8.Values;

                var d9 = new SingleAssignmentDisposable();
                disposables[8] = d9;
                _observer9 = new ZipObserver<T9>(_gate, this, 8, d9);
                base.Queues[8] = _observer9.Values;

                var d10 = new SingleAssignmentDisposable();
                disposables[9] = d10;
                _observer10 = new ZipObserver<T10>(_gate, this, 9, d10);
                base.Queues[9] = _observer10.Values;

                var d11 = new SingleAssignmentDisposable();
                disposables[10] = d11;
                _observer11 = new ZipObserver<T11>(_gate, this, 10, d11);
                base.Queues[10] = _observer11.Values;

                var d12 = new SingleAssignmentDisposable();
                disposables[11] = d12;
                _observer12 = new ZipObserver<T12>(_gate, this, 11, d12);
                base.Queues[11] = _observer12.Values;

                d1.Disposable = source1.SubscribeSafe(_observer1);
                d2.Disposable = source2.SubscribeSafe(_observer2);
                d3.Disposable = source3.SubscribeSafe(_observer3);
                d4.Disposable = source4.SubscribeSafe(_observer4);
                d5.Disposable = source5.SubscribeSafe(_observer5);
                d6.Disposable = source6.SubscribeSafe(_observer6);
                d7.Disposable = source7.SubscribeSafe(_observer7);
                d8.Disposable = source8.SubscribeSafe(_observer8);
                d9.Disposable = source9.SubscribeSafe(_observer9);
                d10.Disposable = source10.SubscribeSafe(_observer10);
                d11.Disposable = source11.SubscribeSafe(_observer11);
                d12.Disposable = source12.SubscribeSafe(_observer12);

                disposables[12] = Disposable.Create(() =>
                {
                    _observer1.Values.Clear();
                    _observer2.Values.Clear();
                    _observer3.Values.Clear();
                    _observer4.Values.Clear();
                    _observer5.Values.Clear();
                    _observer6.Values.Clear();
                    _observer7.Values.Clear();
                    _observer8.Values.Clear();
                    _observer9.Values.Clear();
                    _observer10.Values.Clear();
                    _observer11.Values.Clear();
                    _observer12.Values.Clear();
                });

                return StableCompositeDisposable.Create(disposables);
            }

            protected override TResult GetResult() => _resultSelector(_observer1.Values.Dequeue(), _observer2.Values.Dequeue(), _observer3.Values.Dequeue(), _observer4.Values.Dequeue(), _observer5.Values.Dequeue(), _observer6.Values.Dequeue(), _observer7.Values.Dequeue(), _observer8.Values.Dequeue(), _observer9.Values.Dequeue(), _observer10.Values.Dequeue(), _observer11.Values.Dequeue(), _observer12.Values.Dequeue());
        }
    }

    internal sealed class Zip<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> : Producer<TResult, Zip<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>._>
    {
        private readonly IObservable<T1> _source1;
        private readonly IObservable<T2> _source2;
        private readonly IObservable<T3> _source3;
        private readonly IObservable<T4> _source4;
        private readonly IObservable<T5> _source5;
        private readonly IObservable<T6> _source6;
        private readonly IObservable<T7> _source7;
        private readonly IObservable<T8> _source8;
        private readonly IObservable<T9> _source9;
        private readonly IObservable<T10> _source10;
        private readonly IObservable<T11> _source11;
        private readonly IObservable<T12> _source12;
        private readonly IObservable<T13> _source13;
        private readonly Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> _resultSelector;

        public Zip(IObservable<T1> source1, IObservable<T2> source2, IObservable<T3> source3, IObservable<T4> source4, IObservable<T5> source5, IObservable<T6> source6, IObservable<T7> source7, IObservable<T8> source8, IObservable<T9> source9, IObservable<T10> source10, IObservable<T11> source11, IObservable<T12> source12, IObservable<T13> source13, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> resultSelector)
        {
            _source1 = source1;
            _source2 = source2;
            _source3 = source3;
            _source4 = source4;
            _source5 = source5;
            _source6 = source6;
            _source7 = source7;
            _source8 = source8;
            _source9 = source9;
            _source10 = source10;
            _source11 = source11;
            _source12 = source12;
            _source13 = source13;
            _resultSelector = resultSelector;
        }

        protected override _ CreateSink(IObserver<TResult> observer, IDisposable cancel) => new _(_resultSelector, observer, cancel);

        protected override IDisposable Run(_ sink) => sink.Run(_source1, _source2, _source3, _source4, _source5, _source6, _source7, _source8, _source9, _source10, _source11, _source12, _source13);

        internal sealed class _ : ZipSink<TResult>
        {
            private readonly Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> _resultSelector;

            public _(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> resultSelector, IObserver<TResult> observer, IDisposable cancel)
                : base(13, observer, cancel)
            {
                _resultSelector = resultSelector;
            }

            private ZipObserver<T1> _observer1;
            private ZipObserver<T2> _observer2;
            private ZipObserver<T3> _observer3;
            private ZipObserver<T4> _observer4;
            private ZipObserver<T5> _observer5;
            private ZipObserver<T6> _observer6;
            private ZipObserver<T7> _observer7;
            private ZipObserver<T8> _observer8;
            private ZipObserver<T9> _observer9;
            private ZipObserver<T10> _observer10;
            private ZipObserver<T11> _observer11;
            private ZipObserver<T12> _observer12;
            private ZipObserver<T13> _observer13;

            public IDisposable Run(IObservable<T1> source1, IObservable<T2> source2, IObservable<T3> source3, IObservable<T4> source4, IObservable<T5> source5, IObservable<T6> source6, IObservable<T7> source7, IObservable<T8> source8, IObservable<T9> source9, IObservable<T10> source10, IObservable<T11> source11, IObservable<T12> source12, IObservable<T13> source13)
            {
                var disposables = new IDisposable[14];

                var d1 = new SingleAssignmentDisposable();
                disposables[0] = d1;
                _observer1 = new ZipObserver<T1>(_gate, this, 0, d1);
                base.Queues[0] = _observer1.Values;

                var d2 = new SingleAssignmentDisposable();
                disposables[1] = d2;
                _observer2 = new ZipObserver<T2>(_gate, this, 1, d2);
                base.Queues[1] = _observer2.Values;

                var d3 = new SingleAssignmentDisposable();
                disposables[2] = d3;
                _observer3 = new ZipObserver<T3>(_gate, this, 2, d3);
                base.Queues[2] = _observer3.Values;

                var d4 = new SingleAssignmentDisposable();
                disposables[3] = d4;
                _observer4 = new ZipObserver<T4>(_gate, this, 3, d4);
                base.Queues[3] = _observer4.Values;

                var d5 = new SingleAssignmentDisposable();
                disposables[4] = d5;
                _observer5 = new ZipObserver<T5>(_gate, this, 4, d5);
                base.Queues[4] = _observer5.Values;

                var d6 = new SingleAssignmentDisposable();
                disposables[5] = d6;
                _observer6 = new ZipObserver<T6>(_gate, this, 5, d6);
                base.Queues[5] = _observer6.Values;

                var d7 = new SingleAssignmentDisposable();
                disposables[6] = d7;
                _observer7 = new ZipObserver<T7>(_gate, this, 6, d7);
                base.Queues[6] = _observer7.Values;

                var d8 = new SingleAssignmentDisposable();
                disposables[7] = d8;
                _observer8 = new ZipObserver<T8>(_gate, this, 7, d8);
                base.Queues[7] = _observer8.Values;

                var d9 = new SingleAssignmentDisposable();
                disposables[8] = d9;
                _observer9 = new ZipObserver<T9>(_gate, this, 8, d9);
                base.Queues[8] = _observer9.Values;

                var d10 = new SingleAssignmentDisposable();
                disposables[9] = d10;
                _observer10 = new ZipObserver<T10>(_gate, this, 9, d10);
                base.Queues[9] = _observer10.Values;

                var d11 = new SingleAssignmentDisposable();
                disposables[10] = d11;
                _observer11 = new ZipObserver<T11>(_gate, this, 10, d11);
                base.Queues[10] = _observer11.Values;

                var d12 = new SingleAssignmentDisposable();
                disposables[11] = d12;
                _observer12 = new ZipObserver<T12>(_gate, this, 11, d12);
                base.Queues[11] = _observer12.Values;

                var d13 = new SingleAssignmentDisposable();
                disposables[12] = d13;
                _observer13 = new ZipObserver<T13>(_gate, this, 12, d13);
                base.Queues[12] = _observer13.Values;

                d1.Disposable = source1.SubscribeSafe(_observer1);
                d2.Disposable = source2.SubscribeSafe(_observer2);
                d3.Disposable = source3.SubscribeSafe(_observer3);
                d4.Disposable = source4.SubscribeSafe(_observer4);
                d5.Disposable = source5.SubscribeSafe(_observer5);
                d6.Disposable = source6.SubscribeSafe(_observer6);
                d7.Disposable = source7.SubscribeSafe(_observer7);
                d8.Disposable = source8.SubscribeSafe(_observer8);
                d9.Disposable = source9.SubscribeSafe(_observer9);
                d10.Disposable = source10.SubscribeSafe(_observer10);
                d11.Disposable = source11.SubscribeSafe(_observer11);
                d12.Disposable = source12.SubscribeSafe(_observer12);
                d13.Disposable = source13.SubscribeSafe(_observer13);

                disposables[13] = Disposable.Create(() =>
                {
                    _observer1.Values.Clear();
                    _observer2.Values.Clear();
                    _observer3.Values.Clear();
                    _observer4.Values.Clear();
                    _observer5.Values.Clear();
                    _observer6.Values.Clear();
                    _observer7.Values.Clear();
                    _observer8.Values.Clear();
                    _observer9.Values.Clear();
                    _observer10.Values.Clear();
                    _observer11.Values.Clear();
                    _observer12.Values.Clear();
                    _observer13.Values.Clear();
                });

                return StableCompositeDisposable.Create(disposables);
            }

            protected override TResult GetResult() => _resultSelector(_observer1.Values.Dequeue(), _observer2.Values.Dequeue(), _observer3.Values.Dequeue(), _observer4.Values.Dequeue(), _observer5.Values.Dequeue(), _observer6.Values.Dequeue(), _observer7.Values.Dequeue(), _observer8.Values.Dequeue(), _observer9.Values.Dequeue(), _observer10.Values.Dequeue(), _observer11.Values.Dequeue(), _observer12.Values.Dequeue(), _observer13.Values.Dequeue());
        }
    }

    internal sealed class Zip<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> : Producer<TResult, Zip<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>._>
    {
        private readonly IObservable<T1> _source1;
        private readonly IObservable<T2> _source2;
        private readonly IObservable<T3> _source3;
        private readonly IObservable<T4> _source4;
        private readonly IObservable<T5> _source5;
        private readonly IObservable<T6> _source6;
        private readonly IObservable<T7> _source7;
        private readonly IObservable<T8> _source8;
        private readonly IObservable<T9> _source9;
        private readonly IObservable<T10> _source10;
        private readonly IObservable<T11> _source11;
        private readonly IObservable<T12> _source12;
        private readonly IObservable<T13> _source13;
        private readonly IObservable<T14> _source14;
        private readonly Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> _resultSelector;

        public Zip(IObservable<T1> source1, IObservable<T2> source2, IObservable<T3> source3, IObservable<T4> source4, IObservable<T5> source5, IObservable<T6> source6, IObservable<T7> source7, IObservable<T8> source8, IObservable<T9> source9, IObservable<T10> source10, IObservable<T11> source11, IObservable<T12> source12, IObservable<T13> source13, IObservable<T14> source14, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> resultSelector)
        {
            _source1 = source1;
            _source2 = source2;
            _source3 = source3;
            _source4 = source4;
            _source5 = source5;
            _source6 = source6;
            _source7 = source7;
            _source8 = source8;
            _source9 = source9;
            _source10 = source10;
            _source11 = source11;
            _source12 = source12;
            _source13 = source13;
            _source14 = source14;
            _resultSelector = resultSelector;
        }

        protected override _ CreateSink(IObserver<TResult> observer, IDisposable cancel) => new _(_resultSelector, observer, cancel);

        protected override IDisposable Run(_ sink) => sink.Run(_source1, _source2, _source3, _source4, _source5, _source6, _source7, _source8, _source9, _source10, _source11, _source12, _source13, _source14);

        internal sealed class _ : ZipSink<TResult>
        {
            private readonly Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> _resultSelector;

            public _(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> resultSelector, IObserver<TResult> observer, IDisposable cancel)
                : base(14, observer, cancel)
            {
                _resultSelector = resultSelector;
            }

            private ZipObserver<T1> _observer1;
            private ZipObserver<T2> _observer2;
            private ZipObserver<T3> _observer3;
            private ZipObserver<T4> _observer4;
            private ZipObserver<T5> _observer5;
            private ZipObserver<T6> _observer6;
            private ZipObserver<T7> _observer7;
            private ZipObserver<T8> _observer8;
            private ZipObserver<T9> _observer9;
            private ZipObserver<T10> _observer10;
            private ZipObserver<T11> _observer11;
            private ZipObserver<T12> _observer12;
            private ZipObserver<T13> _observer13;
            private ZipObserver<T14> _observer14;

            public IDisposable Run(IObservable<T1> source1, IObservable<T2> source2, IObservable<T3> source3, IObservable<T4> source4, IObservable<T5> source5, IObservable<T6> source6, IObservable<T7> source7, IObservable<T8> source8, IObservable<T9> source9, IObservable<T10> source10, IObservable<T11> source11, IObservable<T12> source12, IObservable<T13> source13, IObservable<T14> source14)
            {
                var disposables = new IDisposable[15];

                var d1 = new SingleAssignmentDisposable();
                disposables[0] = d1;
                _observer1 = new ZipObserver<T1>(_gate, this, 0, d1);
                base.Queues[0] = _observer1.Values;

                var d2 = new SingleAssignmentDisposable();
                disposables[1] = d2;
                _observer2 = new ZipObserver<T2>(_gate, this, 1, d2);
                base.Queues[1] = _observer2.Values;

                var d3 = new SingleAssignmentDisposable();
                disposables[2] = d3;
                _observer3 = new ZipObserver<T3>(_gate, this, 2, d3);
                base.Queues[2] = _observer3.Values;

                var d4 = new SingleAssignmentDisposable();
                disposables[3] = d4;
                _observer4 = new ZipObserver<T4>(_gate, this, 3, d4);
                base.Queues[3] = _observer4.Values;

                var d5 = new SingleAssignmentDisposable();
                disposables[4] = d5;
                _observer5 = new ZipObserver<T5>(_gate, this, 4, d5);
                base.Queues[4] = _observer5.Values;

                var d6 = new SingleAssignmentDisposable();
                disposables[5] = d6;
                _observer6 = new ZipObserver<T6>(_gate, this, 5, d6);
                base.Queues[5] = _observer6.Values;

                var d7 = new SingleAssignmentDisposable();
                disposables[6] = d7;
                _observer7 = new ZipObserver<T7>(_gate, this, 6, d7);
                base.Queues[6] = _observer7.Values;

                var d8 = new SingleAssignmentDisposable();
                disposables[7] = d8;
                _observer8 = new ZipObserver<T8>(_gate, this, 7, d8);
                base.Queues[7] = _observer8.Values;

                var d9 = new SingleAssignmentDisposable();
                disposables[8] = d9;
                _observer9 = new ZipObserver<T9>(_gate, this, 8, d9);
                base.Queues[8] = _observer9.Values;

                var d10 = new SingleAssignmentDisposable();
                disposables[9] = d10;
                _observer10 = new ZipObserver<T10>(_gate, this, 9, d10);
                base.Queues[9] = _observer10.Values;

                var d11 = new SingleAssignmentDisposable();
                disposables[10] = d11;
                _observer11 = new ZipObserver<T11>(_gate, this, 10, d11);
                base.Queues[10] = _observer11.Values;

                var d12 = new SingleAssignmentDisposable();
                disposables[11] = d12;
                _observer12 = new ZipObserver<T12>(_gate, this, 11, d12);
                base.Queues[11] = _observer12.Values;

                var d13 = new SingleAssignmentDisposable();
                disposables[12] = d13;
                _observer13 = new ZipObserver<T13>(_gate, this, 12, d13);
                base.Queues[12] = _observer13.Values;

                var d14 = new SingleAssignmentDisposable();
                disposables[13] = d14;
                _observer14 = new ZipObserver<T14>(_gate, this, 13, d14);
                base.Queues[13] = _observer14.Values;

                d1.Disposable = source1.SubscribeSafe(_observer1);
                d2.Disposable = source2.SubscribeSafe(_observer2);
                d3.Disposable = source3.SubscribeSafe(_observer3);
                d4.Disposable = source4.SubscribeSafe(_observer4);
                d5.Disposable = source5.SubscribeSafe(_observer5);
                d6.Disposable = source6.SubscribeSafe(_observer6);
                d7.Disposable = source7.SubscribeSafe(_observer7);
                d8.Disposable = source8.SubscribeSafe(_observer8);
                d9.Disposable = source9.SubscribeSafe(_observer9);
                d10.Disposable = source10.SubscribeSafe(_observer10);
                d11.Disposable = source11.SubscribeSafe(_observer11);
                d12.Disposable = source12.SubscribeSafe(_observer12);
                d13.Disposable = source13.SubscribeSafe(_observer13);
                d14.Disposable = source14.SubscribeSafe(_observer14);

                disposables[14] = Disposable.Create(() =>
                {
                    _observer1.Values.Clear();
                    _observer2.Values.Clear();
                    _observer3.Values.Clear();
                    _observer4.Values.Clear();
                    _observer5.Values.Clear();
                    _observer6.Values.Clear();
                    _observer7.Values.Clear();
                    _observer8.Values.Clear();
                    _observer9.Values.Clear();
                    _observer10.Values.Clear();
                    _observer11.Values.Clear();
                    _observer12.Values.Clear();
                    _observer13.Values.Clear();
                    _observer14.Values.Clear();
                });

                return StableCompositeDisposable.Create(disposables);
            }

            protected override TResult GetResult() => _resultSelector(_observer1.Values.Dequeue(), _observer2.Values.Dequeue(), _observer3.Values.Dequeue(), _observer4.Values.Dequeue(), _observer5.Values.Dequeue(), _observer6.Values.Dequeue(), _observer7.Values.Dequeue(), _observer8.Values.Dequeue(), _observer9.Values.Dequeue(), _observer10.Values.Dequeue(), _observer11.Values.Dequeue(), _observer12.Values.Dequeue(), _observer13.Values.Dequeue(), _observer14.Values.Dequeue());
        }
    }

    internal sealed class Zip<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> : Producer<TResult, Zip<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>._>
    {
        private readonly IObservable<T1> _source1;
        private readonly IObservable<T2> _source2;
        private readonly IObservable<T3> _source3;
        private readonly IObservable<T4> _source4;
        private readonly IObservable<T5> _source5;
        private readonly IObservable<T6> _source6;
        private readonly IObservable<T7> _source7;
        private readonly IObservable<T8> _source8;
        private readonly IObservable<T9> _source9;
        private readonly IObservable<T10> _source10;
        private readonly IObservable<T11> _source11;
        private readonly IObservable<T12> _source12;
        private readonly IObservable<T13> _source13;
        private readonly IObservable<T14> _source14;
        private readonly IObservable<T15> _source15;
        private readonly Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> _resultSelector;

        public Zip(IObservable<T1> source1, IObservable<T2> source2, IObservable<T3> source3, IObservable<T4> source4, IObservable<T5> source5, IObservable<T6> source6, IObservable<T7> source7, IObservable<T8> source8, IObservable<T9> source9, IObservable<T10> source10, IObservable<T11> source11, IObservable<T12> source12, IObservable<T13> source13, IObservable<T14> source14, IObservable<T15> source15, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> resultSelector)
        {
            _source1 = source1;
            _source2 = source2;
            _source3 = source3;
            _source4 = source4;
            _source5 = source5;
            _source6 = source6;
            _source7 = source7;
            _source8 = source8;
            _source9 = source9;
            _source10 = source10;
            _source11 = source11;
            _source12 = source12;
            _source13 = source13;
            _source14 = source14;
            _source15 = source15;
            _resultSelector = resultSelector;
        }

        protected override _ CreateSink(IObserver<TResult> observer, IDisposable cancel) => new _(_resultSelector, observer, cancel);

        protected override IDisposable Run(_ sink) => sink.Run(_source1, _source2, _source3, _source4, _source5, _source6, _source7, _source8, _source9, _source10, _source11, _source12, _source13, _source14, _source15);

        internal sealed class _ : ZipSink<TResult>
        {
            private readonly Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> _resultSelector;

            public _(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> resultSelector, IObserver<TResult> observer, IDisposable cancel)
                : base(15, observer, cancel)
            {
                _resultSelector = resultSelector;
            }

            private ZipObserver<T1> _observer1;
            private ZipObserver<T2> _observer2;
            private ZipObserver<T3> _observer3;
            private ZipObserver<T4> _observer4;
            private ZipObserver<T5> _observer5;
            private ZipObserver<T6> _observer6;
            private ZipObserver<T7> _observer7;
            private ZipObserver<T8> _observer8;
            private ZipObserver<T9> _observer9;
            private ZipObserver<T10> _observer10;
            private ZipObserver<T11> _observer11;
            private ZipObserver<T12> _observer12;
            private ZipObserver<T13> _observer13;
            private ZipObserver<T14> _observer14;
            private ZipObserver<T15> _observer15;

            public IDisposable Run(IObservable<T1> source1, IObservable<T2> source2, IObservable<T3> source3, IObservable<T4> source4, IObservable<T5> source5, IObservable<T6> source6, IObservable<T7> source7, IObservable<T8> source8, IObservable<T9> source9, IObservable<T10> source10, IObservable<T11> source11, IObservable<T12> source12, IObservable<T13> source13, IObservable<T14> source14, IObservable<T15> source15)
            {
                var disposables = new IDisposable[16];

                var d1 = new SingleAssignmentDisposable();
                disposables[0] = d1;
                _observer1 = new ZipObserver<T1>(_gate, this, 0, d1);
                base.Queues[0] = _observer1.Values;

                var d2 = new SingleAssignmentDisposable();
                disposables[1] = d2;
                _observer2 = new ZipObserver<T2>(_gate, this, 1, d2);
                base.Queues[1] = _observer2.Values;

                var d3 = new SingleAssignmentDisposable();
                disposables[2] = d3;
                _observer3 = new ZipObserver<T3>(_gate, this, 2, d3);
                base.Queues[2] = _observer3.Values;

                var d4 = new SingleAssignmentDisposable();
                disposables[3] = d4;
                _observer4 = new ZipObserver<T4>(_gate, this, 3, d4);
                base.Queues[3] = _observer4.Values;

                var d5 = new SingleAssignmentDisposable();
                disposables[4] = d5;
                _observer5 = new ZipObserver<T5>(_gate, this, 4, d5);
                base.Queues[4] = _observer5.Values;

                var d6 = new SingleAssignmentDisposable();
                disposables[5] = d6;
                _observer6 = new ZipObserver<T6>(_gate, this, 5, d6);
                base.Queues[5] = _observer6.Values;

                var d7 = new SingleAssignmentDisposable();
                disposables[6] = d7;
                _observer7 = new ZipObserver<T7>(_gate, this, 6, d7);
                base.Queues[6] = _observer7.Values;

                var d8 = new SingleAssignmentDisposable();
                disposables[7] = d8;
                _observer8 = new ZipObserver<T8>(_gate, this, 7, d8);
                base.Queues[7] = _observer8.Values;

                var d9 = new SingleAssignmentDisposable();
                disposables[8] = d9;
                _observer9 = new ZipObserver<T9>(_gate, this, 8, d9);
                base.Queues[8] = _observer9.Values;

                var d10 = new SingleAssignmentDisposable();
                disposables[9] = d10;
                _observer10 = new ZipObserver<T10>(_gate, this, 9, d10);
                base.Queues[9] = _observer10.Values;

                var d11 = new SingleAssignmentDisposable();
                disposables[10] = d11;
                _observer11 = new ZipObserver<T11>(_gate, this, 10, d11);
                base.Queues[10] = _observer11.Values;

                var d12 = new SingleAssignmentDisposable();
                disposables[11] = d12;
                _observer12 = new ZipObserver<T12>(_gate, this, 11, d12);
                base.Queues[11] = _observer12.Values;

                var d13 = new SingleAssignmentDisposable();
                disposables[12] = d13;
                _observer13 = new ZipObserver<T13>(_gate, this, 12, d13);
                base.Queues[12] = _observer13.Values;

                var d14 = new SingleAssignmentDisposable();
                disposables[13] = d14;
                _observer14 = new ZipObserver<T14>(_gate, this, 13, d14);
                base.Queues[13] = _observer14.Values;

                var d15 = new SingleAssignmentDisposable();
                disposables[14] = d15;
                _observer15 = new ZipObserver<T15>(_gate, this, 14, d15);
                base.Queues[14] = _observer15.Values;

                d1.Disposable = source1.SubscribeSafe(_observer1);
                d2.Disposable = source2.SubscribeSafe(_observer2);
                d3.Disposable = source3.SubscribeSafe(_observer3);
                d4.Disposable = source4.SubscribeSafe(_observer4);
                d5.Disposable = source5.SubscribeSafe(_observer5);
                d6.Disposable = source6.SubscribeSafe(_observer6);
                d7.Disposable = source7.SubscribeSafe(_observer7);
                d8.Disposable = source8.SubscribeSafe(_observer8);
                d9.Disposable = source9.SubscribeSafe(_observer9);
                d10.Disposable = source10.SubscribeSafe(_observer10);
                d11.Disposable = source11.SubscribeSafe(_observer11);
                d12.Disposable = source12.SubscribeSafe(_observer12);
                d13.Disposable = source13.SubscribeSafe(_observer13);
                d14.Disposable = source14.SubscribeSafe(_observer14);
                d15.Disposable = source15.SubscribeSafe(_observer15);

                disposables[15] = Disposable.Create(() =>
                {
                    _observer1.Values.Clear();
                    _observer2.Values.Clear();
                    _observer3.Values.Clear();
                    _observer4.Values.Clear();
                    _observer5.Values.Clear();
                    _observer6.Values.Clear();
                    _observer7.Values.Clear();
                    _observer8.Values.Clear();
                    _observer9.Values.Clear();
                    _observer10.Values.Clear();
                    _observer11.Values.Clear();
                    _observer12.Values.Clear();
                    _observer13.Values.Clear();
                    _observer14.Values.Clear();
                    _observer15.Values.Clear();
                });

                return StableCompositeDisposable.Create(disposables);
            }

            protected override TResult GetResult() => _resultSelector(_observer1.Values.Dequeue(), _observer2.Values.Dequeue(), _observer3.Values.Dequeue(), _observer4.Values.Dequeue(), _observer5.Values.Dequeue(), _observer6.Values.Dequeue(), _observer7.Values.Dequeue(), _observer8.Values.Dequeue(), _observer9.Values.Dequeue(), _observer10.Values.Dequeue(), _observer11.Values.Dequeue(), _observer12.Values.Dequeue(), _observer13.Values.Dequeue(), _observer14.Values.Dequeue(), _observer15.Values.Dequeue());
        }
    }

    internal sealed class Zip<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TResult> : Producer<TResult, Zip<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TResult>._>
    {
        private readonly IObservable<T1> _source1;
        private readonly IObservable<T2> _source2;
        private readonly IObservable<T3> _source3;
        private readonly IObservable<T4> _source4;
        private readonly IObservable<T5> _source5;
        private readonly IObservable<T6> _source6;
        private readonly IObservable<T7> _source7;
        private readonly IObservable<T8> _source8;
        private readonly IObservable<T9> _source9;
        private readonly IObservable<T10> _source10;
        private readonly IObservable<T11> _source11;
        private readonly IObservable<T12> _source12;
        private readonly IObservable<T13> _source13;
        private readonly IObservable<T14> _source14;
        private readonly IObservable<T15> _source15;
        private readonly IObservable<T16> _source16;
        private readonly Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TResult> _resultSelector;

        public Zip(IObservable<T1> source1, IObservable<T2> source2, IObservable<T3> source3, IObservable<T4> source4, IObservable<T5> source5, IObservable<T6> source6, IObservable<T7> source7, IObservable<T8> source8, IObservable<T9> source9, IObservable<T10> source10, IObservable<T11> source11, IObservable<T12> source12, IObservable<T13> source13, IObservable<T14> source14, IObservable<T15> source15, IObservable<T16> source16, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TResult> resultSelector)
        {
            _source1 = source1;
            _source2 = source2;
            _source3 = source3;
            _source4 = source4;
            _source5 = source5;
            _source6 = source6;
            _source7 = source7;
            _source8 = source8;
            _source9 = source9;
            _source10 = source10;
            _source11 = source11;
            _source12 = source12;
            _source13 = source13;
            _source14 = source14;
            _source15 = source15;
            _source16 = source16;
            _resultSelector = resultSelector;
        }

        protected override _ CreateSink(IObserver<TResult> observer, IDisposable cancel) => new _(_resultSelector, observer, cancel);

        protected override IDisposable Run(_ sink) => sink.Run(_source1, _source2, _source3, _source4, _source5, _source6, _source7, _source8, _source9, _source10, _source11, _source12, _source13, _source14, _source15, _source16);

        internal sealed class _ : ZipSink<TResult>
        {
            private readonly Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TResult> _resultSelector;

            public _(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TResult> resultSelector, IObserver<TResult> observer, IDisposable cancel)
                : base(16, observer, cancel)
            {
                _resultSelector = resultSelector;
            }

            private ZipObserver<T1> _observer1;
            private ZipObserver<T2> _observer2;
            private ZipObserver<T3> _observer3;
            private ZipObserver<T4> _observer4;
            private ZipObserver<T5> _observer5;
            private ZipObserver<T6> _observer6;
            private ZipObserver<T7> _observer7;
            private ZipObserver<T8> _observer8;
            private ZipObserver<T9> _observer9;
            private ZipObserver<T10> _observer10;
            private ZipObserver<T11> _observer11;
            private ZipObserver<T12> _observer12;
            private ZipObserver<T13> _observer13;
            private ZipObserver<T14> _observer14;
            private ZipObserver<T15> _observer15;
            private ZipObserver<T16> _observer16;

            public IDisposable Run(IObservable<T1> source1, IObservable<T2> source2, IObservable<T3> source3, IObservable<T4> source4, IObservable<T5> source5, IObservable<T6> source6, IObservable<T7> source7, IObservable<T8> source8, IObservable<T9> source9, IObservable<T10> source10, IObservable<T11> source11, IObservable<T12> source12, IObservable<T13> source13, IObservable<T14> source14, IObservable<T15> source15, IObservable<T16> source16)
            {
                var disposables = new IDisposable[17];

                var d1 = new SingleAssignmentDisposable();
                disposables[0] = d1;
                _observer1 = new ZipObserver<T1>(_gate, this, 0, d1);
                base.Queues[0] = _observer1.Values;

                var d2 = new SingleAssignmentDisposable();
                disposables[1] = d2;
                _observer2 = new ZipObserver<T2>(_gate, this, 1, d2);
                base.Queues[1] = _observer2.Values;

                var d3 = new SingleAssignmentDisposable();
                disposables[2] = d3;
                _observer3 = new ZipObserver<T3>(_gate, this, 2, d3);
                base.Queues[2] = _observer3.Values;

                var d4 = new SingleAssignmentDisposable();
                disposables[3] = d4;
                _observer4 = new ZipObserver<T4>(_gate, this, 3, d4);
                base.Queues[3] = _observer4.Values;

                var d5 = new SingleAssignmentDisposable();
                disposables[4] = d5;
                _observer5 = new ZipObserver<T5>(_gate, this, 4, d5);
                base.Queues[4] = _observer5.Values;

                var d6 = new SingleAssignmentDisposable();
                disposables[5] = d6;
                _observer6 = new ZipObserver<T6>(_gate, this, 5, d6);
                base.Queues[5] = _observer6.Values;

                var d7 = new SingleAssignmentDisposable();
                disposables[6] = d7;
                _observer7 = new ZipObserver<T7>(_gate, this, 6, d7);
                base.Queues[6] = _observer7.Values;

                var d8 = new SingleAssignmentDisposable();
                disposables[7] = d8;
                _observer8 = new ZipObserver<T8>(_gate, this, 7, d8);
                base.Queues[7] = _observer8.Values;

                var d9 = new SingleAssignmentDisposable();
                disposables[8] = d9;
                _observer9 = new ZipObserver<T9>(_gate, this, 8, d9);
                base.Queues[8] = _observer9.Values;

                var d10 = new SingleAssignmentDisposable();
                disposables[9] = d10;
                _observer10 = new ZipObserver<T10>(_gate, this, 9, d10);
                base.Queues[9] = _observer10.Values;

                var d11 = new SingleAssignmentDisposable();
                disposables[10] = d11;
                _observer11 = new ZipObserver<T11>(_gate, this, 10, d11);
                base.Queues[10] = _observer11.Values;

                var d12 = new SingleAssignmentDisposable();
                disposables[11] = d12;
                _observer12 = new ZipObserver<T12>(_gate, this, 11, d12);
                base.Queues[11] = _observer12.Values;

                var d13 = new SingleAssignmentDisposable();
                disposables[12] = d13;
                _observer13 = new ZipObserver<T13>(_gate, this, 12, d13);
                base.Queues[12] = _observer13.Values;

                var d14 = new SingleAssignmentDisposable();
                disposables[13] = d14;
                _observer14 = new ZipObserver<T14>(_gate, this, 13, d14);
                base.Queues[13] = _observer14.Values;

                var d15 = new SingleAssignmentDisposable();
                disposables[14] = d15;
                _observer15 = new ZipObserver<T15>(_gate, this, 14, d15);
                base.Queues[14] = _observer15.Values;

                var d16 = new SingleAssignmentDisposable();
                disposables[15] = d16;
                _observer16 = new ZipObserver<T16>(_gate, this, 15, d16);
                base.Queues[15] = _observer16.Values;

                d1.Disposable = source1.SubscribeSafe(_observer1);
                d2.Disposable = source2.SubscribeSafe(_observer2);
                d3.Disposable = source3.SubscribeSafe(_observer3);
                d4.Disposable = source4.SubscribeSafe(_observer4);
                d5.Disposable = source5.SubscribeSafe(_observer5);
                d6.Disposable = source6.SubscribeSafe(_observer6);
                d7.Disposable = source7.SubscribeSafe(_observer7);
                d8.Disposable = source8.SubscribeSafe(_observer8);
                d9.Disposable = source9.SubscribeSafe(_observer9);
                d10.Disposable = source10.SubscribeSafe(_observer10);
                d11.Disposable = source11.SubscribeSafe(_observer11);
                d12.Disposable = source12.SubscribeSafe(_observer12);
                d13.Disposable = source13.SubscribeSafe(_observer13);
                d14.Disposable = source14.SubscribeSafe(_observer14);
                d15.Disposable = source15.SubscribeSafe(_observer15);
                d16.Disposable = source16.SubscribeSafe(_observer16);

                disposables[16] = Disposable.Create(() =>
                {
                    _observer1.Values.Clear();
                    _observer2.Values.Clear();
                    _observer3.Values.Clear();
                    _observer4.Values.Clear();
                    _observer5.Values.Clear();
                    _observer6.Values.Clear();
                    _observer7.Values.Clear();
                    _observer8.Values.Clear();
                    _observer9.Values.Clear();
                    _observer10.Values.Clear();
                    _observer11.Values.Clear();
                    _observer12.Values.Clear();
                    _observer13.Values.Clear();
                    _observer14.Values.Clear();
                    _observer15.Values.Clear();
                    _observer16.Values.Clear();
                });

                return StableCompositeDisposable.Create(disposables);
            }

            protected override TResult GetResult() => _resultSelector(_observer1.Values.Dequeue(), _observer2.Values.Dequeue(), _observer3.Values.Dequeue(), _observer4.Values.Dequeue(), _observer5.Values.Dequeue(), _observer6.Values.Dequeue(), _observer7.Values.Dequeue(), _observer8.Values.Dequeue(), _observer9.Values.Dequeue(), _observer10.Values.Dequeue(), _observer11.Values.Dequeue(), _observer12.Values.Dequeue(), _observer13.Values.Dequeue(), _observer14.Values.Dequeue(), _observer15.Values.Dequeue(), _observer16.Values.Dequeue());
        }
    }


    #endregion

    #endregion
}
