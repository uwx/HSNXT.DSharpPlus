{"Name":"Evaluate/Calculate","Description":"This is submitted as two extension methods as they work together. It is based off of an class designed by sfabriz @ http://www.osix.net/modules/article/?id=761 He has another class that does something a little different but I thought this was a wonderful piece of code so encapsulated it here. I only claim authorship of the conversion and not the underlying logic.","Author":"Daniel Gidman","SubmittedOn":"12/21/2010 4:12:48 PM","Entries":["/// <summary>\r\n/// JavaScript style Eval for simple calculations\r\n/// http://www.osix.net/modules/article/?id=761\r\n/// This is a safe evaluation.  IE will not allow for injection.\r\n/// </summary>\r\n/// <param name=\"e\"></param>\r\n/// <returns></returns>\r\npublic static string Evaluate(this string e)\r\n{\r\n    Func<string, bool> VerifyAllowed = e1 =>\r\n    {\r\n        string allowed = \"0123456789+-*/()%.,\";\r\n        for (int i = 0; i < e1.Length; i++)\r\n        {\r\n            if (allowed.IndexOf(\"\" + e1[i]) == -1)\r\n            {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n\r\n    if (e.Length == 0) { return string.Empty; }\r\n    if (!VerifyAllowed(e)) { return \"String contains illegal characters\"; }\r\n    if (e[0] == '-') { e = \"0\" + e; }\r\n    string res = \"\";\r\n    try\r\n    {\r\n        res = Calculate(e).ToString();\r\n    }\r\n    catch\r\n    {\r\n        return \"The call caused an exception\";\r\n    }\r\n    return res;\r\n}\r\n\r\n/// <summary>\r\n/// JavaScript Eval Calculations for simple calculations\r\n/// http://www.osix.net/modules/article/?id=761\r\n/// This is an unsafe calculation. IE may allow for injection.\r\n/// </summary>\r\n/// <param name=\"e\"></param>\r\n/// <returns></returns>\r\npublic static double Calculate(this string e)\r\n{\r\n    e = e.Replace(\".\", \",\");\r\n    if (e.IndexOf(\"(\") != -1)\r\n    {\r\n        int a = e.LastIndexOf(\"(\");\r\n        int b = e.IndexOf(\")\", a);\r\n        double middle = Calculate(e.Substring(a + 1, b - a - 1));\r\n        return Calculate(e.Substring(0, a) + middle.ToString() + e.Substring(b + 1));\r\n    }\r\n    double result = 0;\r\n    string[] plus = e.Split('+');\r\n    if (plus.Length > 1)\r\n    {\r\n        // there were some +\r\n        result = Calculate(plus[0]);\r\n        for (int i = 1; i < plus.Length; i++)\r\n        {\r\n            result += Calculate(plus[i]);\r\n        }\r\n        return result;\r\n    }\r\n    else\r\n    {\r\n        // no +\r\n        string[] minus = plus[0].Split('-');\r\n        if (minus.Length > 1)\r\n        {\r\n            // there were some -\r\n            result = Calculate(minus[0]);\r\n            for (int i = 1; i < minus.Length; i++)\r\n            {\r\n                result -= Calculate(minus[i]);\r\n            }\r\n            return result;\r\n        }\r\n        else\r\n        {\r\n            // no -\r\n            string[] mult = minus[0].Split('*');\r\n            if (mult.Length > 1)\r\n            {\r\n                // there were some *\r\n                result = Calculate(mult[0]);\r\n                for (int i = 1; i < mult.Length; i++)\r\n                {\r\n                    result *= Calculate(mult[i]);\r\n                }\r\n                return result;\r\n            }\r\n            else\r\n            {\r\n                // no *\r\n                string[] div = mult[0].Split('/');\r\n                if (div.Length > 1)\r\n                {\r\n                    // there were some /\r\n                    result = Calculate(div[0]);\r\n                    for (int i = 1; i < div.Length; i++)\r\n                    {\r\n                        result /= Calculate(div[i]);\r\n                    }\r\n                    return result;\r\n                }\r\n                else\r\n                {\r\n                    // no /\r\n                    string[] mod = mult[0].Split('%');\r\n                    if (mod.Length > 1)\r\n                    {\r\n                        // there were some %\r\n                        result = Calculate(mod[0]);\r\n                        for (int i = 1; i < mod.Length; i++)\r\n                        {\r\n                            result %= Calculate(mod[i]);\r\n                        }\r\n                        return result;\r\n                    }\r\n                    else\r\n                    {\r\n                        // no %\r\n                        return double.Parse(e);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","string e = \"10+10*4\".Evaluate();\r\ndouble d = \"10+10*4\".Calculate();"]}