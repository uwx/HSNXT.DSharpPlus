{"Name":"Sort (Comparison<T> comparison)","Description":"stable, in-place sort (mergesort) of a LinkedList<T>. LinkedList<T> has O(1) insertion, great for large lists. this lets you sort it.","Author":"Piers Haken","SubmittedOn":"10/30/2010 10:36:32 AM","Entries":["//\r\n// Summary:\r\n//     Sorts the elements in the entire System.Collections.Generic.LinkedList<T> using\r\n//     the default comparer.\r\n//\r\npublic static void Sort<T> (this LinkedList<T> @this)\r\n{\r\n\t@this.Sort (Comparer<T>.Default.Compare);\r\n}\r\n\r\n//\r\n// Summary:\r\n//     Sorts the elements in the entire System.Collections.Generic.LinkedList<T> using\r\n//     the specified comparer.\r\n//\r\n// Parameters:\r\n//   comparer:\r\n//     The System.Collections.Generic.IComparer<T> implementation to use when comparing\r\n//     elements, or null to use the default comparer System.Collections.Generic.Comparer<T>.Default.\r\n//\r\npublic static void Sort<T> (this LinkedList<T> @this, IComparer<T> comparer)\r\n{\r\n\tif (comparer == null)\r\n\t\tcomparer = Comparer<T>.Default;\r\n\t@this.Sort (comparer.Compare);\r\n}\r\n\r\n//\r\n// Summary:\r\n//     Sorts the elements in the entire System.Collections.Generic.LinkedList<T> using\r\n//     the specified System.Comparison<T>.\r\n//\r\n// Parameters:\r\n//   comparison:\r\n//     The System.Comparison<T> to use when comparing elements.\r\n//\r\n// Exceptions:\r\n//   System.ArgumentNullException:\r\n//     comparison is null.\r\n//\r\npublic static void Sort<T> (this LinkedList<T> @this, Comparison<T> comparison)\r\n{\r\n\tif (@this == null)\r\n\t\tthrow new NullReferenceException ();\r\n\r\n\tif (comparison == null)\r\n\t\tthrow new ArgumentNullException (\"comparison\");\r\n\r\n\tint count = @this.Count;\r\n\tif (count <= 1)\r\n\t\treturn;\r\n\r\n\t// merge pairs of lists of doubling size\r\n\tfor (int mergeLength = 1; mergeLength < count; mergeLength *= 2)\r\n\t{\r\n\t\tLinkedListNode<T> mergedTail = null;\r\n\t\tLinkedListNode<T> head2;\r\n\t\tfor (LinkedListNode<T> head1 = @this.First; head1 != null; head1 = head2)\r\n\t\t{\r\n\t\t\t// skip over the 1st part to the start 2nd\r\n\t\t\thead2 = head1;\r\n\t\t\tint length1;\r\n\t\t\tfor (length1 = 0; length1 < mergeLength && head2 != null; ++length1)\r\n\t\t\t\thead2 = head2.Next;\r\n\r\n\t\t\t// assume we have a full-length 2nd part\r\n\t\t\tint length2 = mergeLength;\r\n\r\n\t\t\t// while we still have items to merge\r\n\t\t\twhile (length1 > 0 || (length2 > 0 && head2 != null))\r\n\t\t\t{\r\n\t\t\t\tLinkedListNode<T> next;\r\n\r\n\t\t\t\t// determine which part the next item comes from\r\n\t\t\t\tif (length1 != 0 && !(length2 != 0 && head2 != null && comparison (head1.Value, head2.Value) > 0))\r\n\t\t\t\t{\r\n\t\t\t\t\t// take item from 1st part\r\n\t\t\t\t\tDebug.Assert (head1 != null);\r\n\t\t\t\t\tnext = head1;\r\n\t\t\t\t\thead1 = head1.Next;\r\n\r\n\t\t\t\t\tDebug.Assert (length1 > 0);\r\n\t\t\t\t\t--length1;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\r\n\t\t\t\t\t// take item from 2nd part\r\n\t\t\t\t\tDebug.Assert (head2 != null);\r\n\t\t\t\t\tnext = head2;\r\n\t\t\t\t\thead2 = head2.Next;\r\n\r\n\t\t\t\t\tDebug.Assert (length2 > 0);\r\n\t\t\t\t\t--length2;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// append the next item to the merged list\r\n\t\t\t\tif (mergedTail == null)\r\n\t\t\t\t{\r\n\t\t\t\t\t// start a new merged list at the front of the source list\r\n\t\t\t\t\tif (@this.First != next)\t// check for no-op\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t@this.Remove (next);\r\n\t\t\t\t\t\t@this.AddFirst (next);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if (mergedTail.Next != next)\t// check for no-op\r\n\t\t\t\t{\r\n\t\t\t\t\t@this.Remove (next);\r\n\t\t\t\t\t@this.AddAfter (mergedTail, next);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// advance the merged tail\r\n\t\t\t\tmergedTail = next;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}","LinkedList<int> list = new LinkedList<int> (Enumerable.Range (0, 100).Reverse ());\r\nlist.Sort ();\r\nConsole.WriteLine (string.Join (\", \", from l in list select l.ToString ()));"]}