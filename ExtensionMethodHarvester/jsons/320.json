{"Name":"CacheGeneratedResults","Description":"Caches the results of generator methods so that expensive enumerations are not repeated if they are enumerated multiple times. Yet it caches the results lazily, allowing for memory efficiency where possible.","Author":"Andrew Arnott","SubmittedOn":"4/30/2012 1:03:52 AM","Entries":["//-----------------------------------------------------------------------\r\n// <copyright file=\"EnumerableCache.cs\" company=\"Andrew Arnott\">\r\n//     Copyright (c) Andrew Arnott. All rights reserved.\r\n//     This code is released under the Microsoft Public License (Ms-PL).\r\n// </copyright>\r\n//-----------------------------------------------------------------------\r\n\r\nnamespace IEnumeratorCache {\r\n\tusing System;\r\n\tusing System.Collections;\r\n\tusing System.Collections.Generic;\r\n\r\n\t/// <summary>\r\n\t/// Extension methods for <see cref=\"IEnumerable&lt;T&gt;\"/> types.\r\n\t/// </summary>\r\n\tpublic static class EnumerableCacheExtensions {\r\n\t\t/// <summary>\r\n\t\t/// Caches the results of enumerating over a given object so that subsequence enumerations\r\n\t\t/// don't require interacting with the object a second time.\r\n\t\t/// </summary>\r\n\t\t/// <typeparam name=\"T\">The type of element found in the enumeration.</typeparam>\r\n\t\t/// <param name=\"sequence\">The enumerable object.</param>\r\n\t\t/// <returns>\r\n\t\t/// Either a new enumerable object that caches enumerated results, or the original, <paramref name=\"sequence\"/>\r\n\t\t/// object if no caching is necessary to avoid additional CPU work.\r\n\t\t/// </returns>\r\n\t\t/// <remarks>\r\n\t\t/// \t<para>This is designed for use on the results of generator methods (the ones with <c>yield return</c> in them)\r\n\t\t/// so that only those elements in the sequence that are needed are ever generated, while not requiring\r\n\t\t/// regeneration of elements that are enumerated over multiple times.</para>\r\n\t\t/// \t<para>This can be a huge performance gain if enumerating multiple times over an expensive generator method.</para>\r\n\t\t/// \t<para>Some enumerable types such as collections, lists, and already-cached generators do not require\r\n\t\t/// any (additional) caching, and this method will simply return those objects rather than caching them\r\n\t\t/// to avoid double-caching.</para>\r\n\t\t/// </remarks>\r\n\t\tpublic static IEnumerable<T> CacheGeneratedResults<T>(this IEnumerable<T> sequence) {\r\n\t\t\t// Don't create a cache for types that don't need it.\r\n\t\t\tif (sequence is IList<T> ||\r\n\t\t\t\tsequence is ICollection<T> ||\r\n\t\t\t\tsequence is Array ||\r\n\t\t\t\tsequence is EnumerableCache<T>) {\r\n\t\t\t\treturn sequence;\r\n\t\t\t}\r\n\r\n\t\t\treturn new EnumerableCache<T>(sequence);\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// A wrapper for <see cref=\"IEnumerable&lt;T&gt;\"/> types and returns a caching <see cref=\"IEnumerator&lt;T&gt;\"/>\r\n\t\t/// from its <see cref=\"IEnumerable&lt;T&gt;.GetEnumerator\"/> method.\r\n\t\t/// </summary>\r\n\t\t/// <typeparam name=\"T\">The type of element in the sequence.</typeparam>\r\n\t\tprivate class EnumerableCache<T> : IEnumerable<T> {\r\n\t\t\t/// <summary>\r\n\t\t\t/// The results from enumeration of the live object that have been collected thus far.\r\n\t\t\t/// </summary>\r\n\t\t\tprivate List<T> cache;\r\n\r\n\t\t\t/// <summary>\r\n\t\t\t/// The original generator method or other enumerable object whose contents should only be enumerated once.\r\n\t\t\t/// </summary>\r\n\t\t\tprivate IEnumerable<T> generator;\r\n\r\n\t\t\t/// <summary>\r\n\t\t\t/// The enumerator we're using over the generator method's results.\r\n\t\t\t/// </summary>\r\n\t\t\tprivate IEnumerator<T> generatorEnumerator;\r\n\r\n\t\t\t/// <summary>\r\n\t\t\t/// The sync object our caching enumerators use when adding a new live generator method result to the cache.\r\n\t\t\t/// </summary>\r\n\t\t\t/// <remarks>\r\n\t\t\t/// Although individual enumerators are not thread-safe, this <see cref=\"IEnumerable&lt;T&gt;\"/> should be\r\n\t\t\t/// thread safe so that multiple enumerators can be created from it and used from different threads.\r\n\t\t\t/// </remarks>\r\n\t\t\tprivate object generatorLock = new object();\r\n\r\n\t\t\t/// <summary>\r\n\t\t\t/// Initializes a new instance of the EnumerableCache class.\r\n\t\t\t/// </summary>\r\n\t\t\t/// <param name=\"generator\">The generator.</param>\r\n\t\t\tinternal EnumerableCache(IEnumerable<T> generator) {\r\n\t\t\t\tif (generator == null) {\r\n\t\t\t\t\tthrow new ArgumentNullException(\"generator\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.generator = generator;\r\n\t\t\t}\r\n\r\n\t\t\t#region IEnumerable<T> Members\r\n\r\n\t\t\t/// <summary>\r\n\t\t\t/// Returns an enumerator that iterates through the collection.\r\n\t\t\t/// </summary>\r\n\t\t\t/// <returns>\r\n\t\t\t/// A <see cref=\"T:System.Collections.Generic.IEnumerator`1\"/> that can be used to iterate through the collection.\r\n\t\t\t/// </returns>\r\n\t\t\tpublic IEnumerator<T> GetEnumerator() {\r\n\t\t\t\tif (this.generatorEnumerator == null) {\r\n\t\t\t\t\tthis.cache = new List<T>();\r\n\t\t\t\t\tthis.generatorEnumerator = this.generator.GetEnumerator();\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn new EnumeratorCache(this);\r\n\t\t\t}\r\n\r\n\t\t\t#endregion\r\n\r\n\t\t\t#region IEnumerable Members\r\n\r\n\t\t\t/// <summary>\r\n\t\t\t/// Returns an enumerator that iterates through a collection.\r\n\t\t\t/// </summary>\r\n\t\t\t/// <returns>\r\n\t\t\t/// An <see cref=\"T:System.Collections.IEnumerator\"/> object that can be used to iterate through the collection.\r\n\t\t\t/// </returns>\r\n\t\t\tSystem.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() {\r\n\t\t\t\treturn this.GetEnumerator();\r\n\t\t\t}\r\n\r\n\t\t\t#endregion\r\n\r\n\t\t\t/// <summary>\r\n\t\t\t/// An enumerator that uses cached enumeration results whenever they are available,\r\n\t\t\t/// and caches whatever results it has to pull from the original <see cref=\"IEnumerable&lt;T&gt;\"/> object.\r\n\t\t\t/// </summary>\r\n\t\t\tprivate class EnumeratorCache : IEnumerator<T> {\r\n\t\t\t\t/// <summary>\r\n\t\t\t\t/// The parent enumeration wrapper class that stores the cached results.\r\n\t\t\t\t/// </summary>\r\n\t\t\t\tprivate EnumerableCache<T> parent;\r\n\r\n\t\t\t\t/// <summary>\r\n\t\t\t\t/// The position of this enumerator in the cached list.\r\n\t\t\t\t/// </summary>\r\n\t\t\t\tprivate int cachePosition = -1;\r\n\r\n\t\t\t\t/// <summary>\r\n\t\t\t\t/// Initializes a new instance of the <see cref=\"EnumerableCache&lt;T&gt;.EnumeratorCache\"/> class.\r\n\t\t\t\t/// </summary>\r\n\t\t\t\t/// <param name=\"parent\">The parent cached enumerable whose GetEnumerator method is calling this constructor.</param>\r\n\t\t\t\tinternal EnumeratorCache(EnumerableCache<T> parent) {\r\n\t\t\t\t\tif (parent == null) {\r\n\t\t\t\t\t\tthrow new ArgumentNullException(\"parent\");\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis.parent = parent;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t#region IEnumerator<T> Members\r\n\r\n\t\t\t\t/// <summary>\r\n\t\t\t\t/// Gets the element in the collection at the current position of the enumerator.\r\n\t\t\t\t/// </summary>\r\n\t\t\t\t/// <returns>\r\n\t\t\t\t/// The element in the collection at the current position of the enumerator.\r\n\t\t\t\t/// </returns>\r\n\t\t\t\tpublic T Current {\r\n\t\t\t\t\tget {\r\n\t\t\t\t\t\tif (this.cachePosition < 0 || this.cachePosition >= this.parent.cache.Count) {\r\n\t\t\t\t\t\t\tthrow new InvalidOperationException();\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn this.parent.cache[this.cachePosition];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t#endregion\r\n\r\n\t\t\t\t#region IEnumerator Properties\r\n\r\n\t\t\t\t/// <summary>\r\n\t\t\t\t/// Gets the element in the collection at the current position of the enumerator.\r\n\t\t\t\t/// </summary>\r\n\t\t\t\t/// <returns>\r\n\t\t\t\t/// The element in the collection at the current position of the enumerator.\r\n\t\t\t\t/// </returns>\r\n\t\t\t\tobject System.Collections.IEnumerator.Current {\r\n\t\t\t\t\tget { return this.Current; }\r\n\t\t\t\t}\r\n\r\n\t\t\t\t#endregion\r\n\r\n\t\t\t\t#region IDisposable Members\r\n\r\n\t\t\t\t/// <summary>\r\n\t\t\t\t/// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.\r\n\t\t\t\t/// </summary>\r\n\t\t\t\tpublic void Dispose() {\r\n\t\t\t\t\tthis.Dispose(true);\r\n\t\t\t\t\tGC.SuppressFinalize(this);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t#endregion\r\n\r\n\t\t\t\t#region IEnumerator Methods\r\n\r\n\t\t\t\t/// <summary>\r\n\t\t\t\t/// Advances the enumerator to the next element of the collection.\r\n\t\t\t\t/// </summary>\r\n\t\t\t\t/// <returns>\r\n\t\t\t\t/// true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.\r\n\t\t\t\t/// </returns>\r\n\t\t\t\t/// <exception cref=\"T:System.InvalidOperationException\">\r\n\t\t\t\t/// The collection was modified after the enumerator was created.\r\n\t\t\t\t/// </exception>\r\n\t\t\t\tpublic bool MoveNext() {\r\n\t\t\t\t\tthis.cachePosition++;\r\n\t\t\t\t\tif (this.cachePosition >= this.parent.cache.Count) {\r\n\t\t\t\t\t\tlock (this.parent.generatorLock) {\r\n\t\t\t\t\t\t\tif (this.cachePosition >= this.parent.cache.Count) {\r\n\t\t\t\t\t\t\t\tif (this.parent.generatorEnumerator.MoveNext()) {\r\n\t\t\t\t\t\t\t\t\tthis.parent.cache.Add(this.parent.generatorEnumerator.Current);\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/// <summary>\r\n\t\t\t\t/// Sets the enumerator to its initial position, which is before the first element in the collection.\r\n\t\t\t\t/// </summary>\r\n\t\t\t\t/// <exception cref=\"T:System.InvalidOperationException\">\r\n\t\t\t\t/// The collection was modified after the enumerator was created.\r\n\t\t\t\t/// </exception>\r\n\t\t\t\tpublic void Reset() {\r\n\t\t\t\t\tthis.cachePosition = -1;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t#endregion\r\n\r\n\t\t\t\t/// <summary>\r\n\t\t\t\t/// Releases unmanaged and - optionally - managed resources\r\n\t\t\t\t/// </summary>\r\n\t\t\t\t/// <param name=\"disposing\"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>\r\n\t\t\t\tprotected virtual void Dispose(bool disposing) {\r\n\t\t\t\t\t// Nothing to do here.\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}","// See http://bit.ly/Kl1kSJ for a more complete example and a blog post explaining it all.\r\n\r\npublic void PrintNumbers() {\r\n\tIEnumerable<int> numbers = GetNumbers().CacheGeneratedResults();\r\n\r\n\t// Print to the screen.\r\n\tforeach(int element in numbers) {\r\n\t\tConsole.WriteLine(element);\r\n\t}\r\n\r\n\t// Print to the log file as well.\r\n\tforeach(int element in numbers) {\r\n\t\tLogger.Log(element);\r\n\t}\r\n}"]}