{"Name":"Aggregate","Description":"Since System.Linq.Enumerable.Aggregate throws a System.InvalidOperationException in case the given list is empty you can't use this function in a complex linq expression. This aggregate version simply returns a defaultvalue if the list is empty","Author":"RW","SubmittedOn":"2/18/2009 11:37:02 AM","Entries":["namespace ExtensionMethods\r\n{\r\n\tpublic static class Enumerable\r\n\t{\r\n\t\tpublic static T Aggregate<T>(\r\n\t\t\tthis IEnumerable<T> list, Func<T, T, T> aggregateFunction)\r\n\t\t{\r\n\t\t\treturn Aggregate<T>(list, default(T), aggregateFunction);\r\n\t\t}\r\n\r\n\t\tpublic static T Aggregate<T>(this IEnumerable<T> list, T defaultValue,\r\n\t\t\tFunc<T, T, T> aggregateFunction)\r\n\t\t{\r\n\t\t\treturn list.Count() <= 0 ?\r\n\t\t\t\tdefaultValue : list.Aggregate<T>(aggregateFunction);\r\n\t\t}\r\n\t}\r\n}","return (  from x in _map.Keys\r\n\t  where CheckValue(x)\r\n\t  select _map[x]).\t\t\t    Aggregate(MyFlags.None, (x, y) => x | y);"]}