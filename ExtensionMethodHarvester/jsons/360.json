{"Name":"SplitUp()","Description":"This SplitUp() extension method takes a sequence and splits it up into subsequences that each have a maximum length. See http://peshir.blogspot.nl/2011/02/example-of-c-lazy-functional.html for more information.","Author":"peSHIr","SubmittedOn":"5/6/2014 12:47:06 PM","Entries":["namespace peSHIr.Utilities\r\n{\r\n using System;\r\n using System.Linq;\r\n using System.Text;\r\n using System.Collections.Generic;\r\n \r\n /// <summary>Utility code for working with sequences</summary>\r\n public static class SequenceUtility\r\n {\r\n  /// <summary>Split up sequence of items</summary>\r\n  /// <typeparam name=\"T\">Item type</typeparam>\r\n  /// <param name=\"input\">Input sequence</param>\r\n  /// <param name=\"n\">Maximum number of items per sublists</param>\r\n  /// <returns>Sequence of lists with a maximum\r\n  /// of <paramref name=\"n\"/> items</returns>\r\n  /// <remarks>Might need a suppression of code analysis rule\r\n  /// CA1006 because of the nested generic type in the method\r\n  /// signature.</remarks>\r\n  public static IEnumerable<IEnumerable<T>>\r\n   SplitUp<T>(this IEnumerable<T> input, int n)\r\n  {\r\n   // Non-lazy error checking\r\n   if (input == null) throw new ArgumentNullException(\"input\");\r\n   if (n < 1) throw new ArgumentOutOfRangeException(\"n\", n, \"<1\");\r\n   return SplitUpLazy(input, n);\r\n  }\r\n \r\n  private static IEnumerable<IEnumerable<T>>\r\n   SplitUpLazy<T>(IEnumerable<T> input, int n)\r\n  {\r\n   // Lazy yield based implementation\r\n   var list = new List<T>();\r\n   foreach (T item in input)\r\n   {\r\n    list.Add(item);\r\n    if (list.Count == n)\r\n    {\r\n     yield return list;\r\n     list = new List<T>();\r\n    }\r\n   }\r\n   if (list.Count > 0) yield return list;\r\n   yield break;\r\n  }\r\n }\r\n}","namespace SplitUpExample\r\n{\r\n  using System;\r\n  using System.Linq;\r\n  using System.Collections.Generic;\r\n  using peSHIr.Utilities;\r\n \r\n  class Program\r\n  {\r\n    static bool TraceDataCreation;\r\n         \r\n    static Action<string> println = text => Console.WriteLine(text);\r\n    static Action<string> print = text => Console.Write(text);\r\n    static Action newline = () => Console.WriteLine();\r\n \r\n    static void Main(string[] args)\r\n    {\r\n      newline();\r\n      println(\"* How can SplitUp() be used for paging\");\r\n      TraceDataCreation = false;\r\n             \r\n      var allData = TestData(64);\r\n      var pagedData = allData.SplitUp(7);\r\n      foreach (var page in pagedData)\r\n      {\r\n        print(\"Page:\");\r\n        foreach (int i in page)\r\n        {\r\n           print(\" \");\r\n           print(i.ToString());\r\n        }\r\n        newline();\r\n      }\r\n \r\n      newline();\r\n      println(\"* And is it really lazy?\");\r\n      TraceDataCreation = true;\r\n             \r\n      println(\"Calling SplitUp() on infinite sequence now\");\r\n      var pagedInfinity = TestData().SplitUp(4);\r\n \r\n      println(\"Retrieving first page now\");\r\n      var page1 = pagedInfinity.ElementAt(0);\r\n             \r\n      println(\"Retrieving third page now\");\r\n      var page3 = pagedInfinity.ElementAt(2);\r\n             \r\n      Action<string,int,int> results = (text,sum,count)\r\n        => Console.WriteLine(\"{0}: {1}, {2}\", text, sum, count);\r\n \r\n      println(\"Showing results:\");\r\n      results(\"First page\", page1.Sum(), page1.Count());\r\n      results(\"Third page\", page3.Sum(), page3.Count());\r\n      println(\"So yes, SplitUp() is lazy like LINQ! ;-)\");\r\n \r\n#if DEBUG\r\n      newline();\r\n      println(\"(Key to quit)\");\r\n      Console.ReadKey();\r\n#endif\r\n    }\r\n \r\n    static IEnumerable<int> TestData(int n)\r\n    {\r\n      return TestData().Take(n);\r\n    }\r\n \r\n    static IEnumerable<int> TestData()\r\n    {\r\n      // WARNING: this returns an infinite sequence!\r\n      // Or at least: until int overflows... ;-)\r\n      int i = 0;\r\n      while (true)\r\n      {\r\n        if (TraceDataCreation)\r\n          Console.WriteLine(\"Yielding {0}\", i);\r\n        yield return i++;\r\n      }\r\n    }\r\n \r\n  }\r\n \r\n}"]}