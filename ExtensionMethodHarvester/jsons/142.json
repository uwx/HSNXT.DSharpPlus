{"Name":"Async","Description":"Starts execution of IQueryable on a ThreadPool thread and returns immediately with a \"end\" method to call once the result is needed.","Author":"ulrikb.worldpress.com","SubmittedOn":"10/14/2010 2:26:41 PM","Entries":["public static Func<TResult> Async<T, TResult>(this IEnumerable<T> enumerable, Func<IEnumerable<T>, TResult> asyncSelector)\r\n        {\r\n            System.Diagnostics.Debug.Assert(!(enumerable is ICollection), \"Async does not work on arrays/lists/collections, only on true enumerables/queryables.\");\r\n\r\n            // Create delegate to exec async\r\n            Func<IEnumerable<T>, TResult> work = (e => asyncSelector(e));\r\n\r\n            // Launch it\r\n            IAsyncResult r = work.BeginInvoke(enumerable, null, null);\r\n\r\n            // Return method that will block until completed and rethrow exceptions if any\r\n            return () => work.EndInvoke(r);\r\n        }","// Define some expensive query\r\nIQueryable<string> myExpensiveQuery = context.SystemLog.Where(l => l.Timestamp >= DateTime.Today.AddDays(-10));\r\n\r\n// Start async processing\r\nFunc<string[]> waitForQueryData = myExpensiveQuery.Async(e => e.ToArray());\r\n\r\n// Do a lot of other work, e.g. other queries\r\n\r\n// Need my query result now, so block until it's ready and get result\r\nstring[] myQueryResults = waitForQueryData();"]}