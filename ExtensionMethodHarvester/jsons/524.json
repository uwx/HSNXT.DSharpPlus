{"Name":"InnerTruncate","Description":"Truncates the given string by stripping out the center and replacing it with an elipsis so that the beginning and end of the string are retained. For example, \"This string has too many characters for its own good.\"InnerTruncate(32) yields \"This string has...its own good.\"","Author":"Partial Method","SubmittedOn":"9/22/2009 1:45:26 AM","Entries":["public static string InnerTruncate(this string value, \r\n     int maxLength)\r\n{\r\n    // If there is no need to truncate then\r\n    // return what we were given.\r\n    if (string.IsNullOrEmpty(value) \r\n            || value.Length <= maxLength)\r\n    {\r\n        return value;\r\n    } // end if\r\n\r\n     // Figure out how many characters would be in \r\n     // each  half if we were to have\r\n     // exactly the same length string on either side \r\n     // of the elipsis.\r\n     int charsInEachHalf = (maxLength - 3) / 2;\r\n\r\n     // Get the string to the right of the elipsis \r\n     // and then trim the beginning.  There is no\r\n     // need to have a space immediately following \r\n     // the elipsis.\r\n     string right = value.Substring(\r\n         value.Length - charsInEachHalf, charsInEachHalf)\r\n         .TrimStart();\r\n\r\n      // Get the string to the left of the elipsis.\r\n      // We don't use \"charsInEachHalf \" here\r\n      // because we may be able to take more characters\r\n      // than that if \"right\" was trimmed.\r\n      string left = value.Substring(\r\n          0, (maxLength - 3) - right.Length)\r\n          .TrimEnd();\r\n\r\n       // Concatenate and return the result.\r\n       return string.Format(\"{0}...{1}\", left, right);\r\n} // end InnerTruncate","string sentence = \"Truncate the really long string.\";\r\n\r\nvar truncated = sentence.InnerTruncate(10);\r\n\r\nAssert.AreEqual(\"Truncate...string.\", truncated);"]}