{"Name":"DateTimeFloor;DateTimeCeiling","Description":"Floor, Ceiling, Midpoint and Rounding calculations for various time intervals.","Author":"Jeff Banjavcic","SubmittedOn":"3/9/2017 2:37:45 AM","Entries":["public static class DateExtensions\r\n{\r\n    static public DateTime DateTimeFloor(this DateTime dt, TimeInterval Interval)\r\n    {\r\n        return WorkMethod(dt, 0L, Interval);\r\n    }\r\n    static public DateTime DateTimeMidpoint(this DateTime dt, TimeInterval Interval)\r\n    {\r\n        return WorkMethod(dt, 2L, Interval);\r\n    }\r\n    static public DateTime DateTimeCeiling(this DateTime dt, TimeInterval Interval)\r\n    {\r\n        return WorkMethod(dt, 1L, Interval);\r\n    }\r\n    static public DateTime DateTimeCeilingUnbounded(this DateTime dt, TimeInterval Interval)\r\n    {\r\n        return WorkMethod(dt, 1L, Interval).AddTicks(-1);\r\n    }\r\n    static public DateTime DateTimeRound(this DateTime dt, TimeInterval Interval)\r\n    {\r\n        if (dt >= WorkMethod(dt, 2L, Interval))\r\n            return WorkMethod(dt, 1L, Interval);\r\n        else\r\n            return WorkMethod(dt, 0L, Interval);\r\n    }\r\n    public enum TimeInterval : long\r\n    {\r\n        YearFromJanuary = 120L,\r\n        YearFromFebruary = 121L,\r\n        YearFromMarch = 122L,\r\n        YearFromApril = 123L,\r\n        YearFromMay = 124L,\r\n        YearFromJune = 125L,\r\n        YearFromJuly = 126L,\r\n        YearFromAugust = 127L,\r\n        YearFromSeptember = 128L,\r\n        YearFromOctober = 129L,\r\n        YearFromNovember = 130L,\r\n        YearFromDecember = 131L,\r\n        HalfYearFromJanuary = 60L,\r\n        HalfYearFromFebruary = 61L,\r\n        HalfYearFromMarch = 62L,\r\n        HalfYearFromApril = 63L,\r\n        HalfYearFromMay = 64L,\r\n        HalfYearFromJune = 65L,\r\n        QuarterYearFromJanuary = 30L,\r\n        QuarterYearFromFebruary = 31L,\r\n        QuarterYearFromMarch = 32L,\r\n        BiMonthlyFromJanuary = 20L,\r\n        BiMonthlyFromFebruary = 21L,\r\n        OneMonth = 10L,\r\n        OneWeekFromSunday = 1L,\r\n        OneWeekFromMonday = 2L,\r\n        OneWeekFromTuesday = 3L,\r\n        OneWeekFromWednesday = 4L,\r\n        OneWeekFromThursday = 5L,\r\n        OneWeekFromFriday = 6L,\r\n        OneWeekFromSaturday = 7L,\r\n        OneDay = TimeSpan.TicksPerDay,\r\n        TwelveHour = TimeSpan.TicksPerHour * 12L,\r\n        SixHour = TimeSpan.TicksPerHour * 6L,\r\n        ThreeHour = TimeSpan.TicksPerHour * 3L,\r\n        OneHour = TimeSpan.TicksPerHour,\r\n        HalfHour = TimeSpan.TicksPerMinute * 30L,\r\n        QuarterHour = TimeSpan.TicksPerMinute * 15L,\r\n        OneMinute = TimeSpan.TicksPerMinute,\r\n        HalfMinute = TimeSpan.TicksPerSecond * 30L,\r\n        QuarterMinute = TimeSpan.TicksPerSecond * 15L,\r\n        OneSecond = TimeSpan.TicksPerSecond,\r\n        TenthOfASecond = TimeSpan.TicksPerSecond / 10L,\r\n        HundrethOfASecond = TimeSpan.TicksPerSecond / 100L,\r\n        ThousandthOfASecond = TimeSpan.TicksPerSecond / 1000L\r\n    }\r\n    static private DateTime WorkMethod(DateTime dt, long ReturnType, TimeInterval Interval)\r\n    {\r\n        long Interval1 = (long)Interval;\r\n        long TicksFromFloor = 0L;\r\n        int IntervalFloor = 0;\r\n        int FloorOffset = 0;\r\n        int IntervalLength = 0;\r\n        DateTime floorDate;\r\n        DateTime ceilingDate;\r\n\r\n        if (Interval1 > 132L) //Set variables to calculate date for time interval less than one day.\r\n        {\r\n            floorDate = new DateTime(dt.Ticks - (dt.Ticks % Interval1), dt.Kind);\r\n            if (ReturnType != 0L)\r\n                TicksFromFloor = Interval1 / ReturnType;\r\n        }\r\n        else if (Interval1 < 8L) //Set variables to calculate date for time interval of one week.\r\n        {\r\n            IntervalFloor = (int)(Interval1) - 1;\r\n            FloorOffset = (int)dt.DayOfWeek * -1;\r\n            floorDate = new DateTime(dt.Year, dt.Month, dt.Day, 0, 0, 0, dt.Kind).AddDays(-(IntervalFloor > FloorOffset ? FloorOffset + 7 - IntervalFloor : FloorOffset - IntervalFloor));\r\n            if (ReturnType != 0L)\r\n                TicksFromFloor = TimeSpan.TicksPerDay * 7L / ReturnType;\r\n        }\r\n        else //Set variables to calculate date for time interval one month or greater.\r\n        {\r\n            IntervalLength = Interval1 >= 130L ? 12 : (int)(Interval1 / 10L);\r\n            IntervalFloor = (int)(Interval1 % IntervalLength);\r\n            FloorOffset = (dt.Month - 1) % IntervalLength;\r\n            floorDate = new DateTime(dt.Year, dt.Month, 1, 0, 0, 0, dt.Kind).AddMonths(-(IntervalFloor > FloorOffset ? FloorOffset + IntervalLength - IntervalFloor : FloorOffset - IntervalFloor));\r\n            if (ReturnType != 0L)\r\n            {\r\n                ceilingDate = floorDate.AddMonths(IntervalLength);\r\n                TicksFromFloor = (long)ceilingDate.Subtract(floorDate).Ticks / ReturnType;\r\n            }\r\n        }\r\n        return floorDate.AddTicks(TicksFromFloor);\r\n    }\r\n}","DateTime currentHour = DateTime.Now.DateTimeFloor(DateExtensions.TimeInterval.OneHour); // Returns the current date and time with the minutes and seconds set to zero.\r\nDateTime nextYear = DateTime.Now.DateTimeCeiling(DateExtensions.TimeInterval.YearFromJanuary); // Returns January 1 of next year at midnight."]}